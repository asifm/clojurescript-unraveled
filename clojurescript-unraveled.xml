<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<book lang="en">
<bookinfo>
<title>ClojureScript Unraveled (2nd edition)</title>
<date>2019-07-16</date>
<authorgroup>
<author>
<firstname>Andrey</firstname>
<surname>Antukh</surname>
<email>niwi@niwi.nz</email>
</author>
<author>
<firstname>Alejandro</firstname>
<surname>Gómez</surname>
<email>alejandro@dialelo.com</email>
</author>
</authorgroup>
<revhistory>
<revision>
<revnumber>6</revnumber>
<date>2019-07-16</date>
<authorinitials>AA</authorinitials>
</revision>
</revhistory>
</bookinfo>
<chapter id="about-this-book">
<title>About this book</title>
<simpara>This book covers the ClojureScript programming language, serves as a detailed guide
of its tooling for development, and presents a series of articles about topics that
are applicable to day-to-day programming in ClojureScript.</simpara>
<simpara>It is not an introductory book to programming in that it assumes the reader has
experience programming in at least one language. However, it doesn&#8217;t assume
experience with <emphasis>Clojure</emphasis> or functional programming. We&#8217;ll try to include links to
reference material when talking about the theoretical underpinnings of ClojureScript
that may not be familiar to everyone.</simpara>
<simpara>Since the ClojureScript documentation is good but sparse, we wanted to write a
compendium of reference information and extensive examples to serve as a
ClojureScript primer as well as a series of practical how-to&#8217;s. This document will
evolve with the ClojureScript language, both as a reference of the language features
and as a sort of cookbook with practical programming recipes.</simpara>
<simpara>You&#8217;ll get the most out of this book if you:</simpara>
<itemizedlist>
<listitem>
<simpara>are curious about ClojureScript or functional programming and have some programming
experience;</simpara>
</listitem>
<listitem>
<simpara>write JavaScript or any other language that compiles to it and want to know what
ClojureScript has to offer;</simpara>
</listitem>
<listitem>
<simpara>already know some Clojure and want to learn how ClojureScript differs from it, plus
practical topics like how to target both languages with the same code base.</simpara>
</listitem>
</itemizedlist>
<simpara>Don&#8217;t be turned off if you don&#8217;t see yourself in any of the above groups. We
encourage you to give this book a try and to give us feedback on how we can make it
more accessible.  Our goal is to make ClojureScript more friendly to newcomers and
spread the ideas about programming that Clojure has helped popularize, as we see a
lot of value in them.</simpara>
<simpara>This is a list of translations of the book:</simpara>
<itemizedlist>
<listitem>
<simpara>Ukrainian: <ulink url="https://lambdabooks.github.io/clojurescript-unraveled/">https://lambdabooks.github.io/clojurescript-unraveled/</ulink></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter id="introduction">
<title>Introduction</title>
<blockquote>
<attribution>
Rich Hickey
</attribution>
<simpara>Why are we doing this? Because Clojure <emphasis>rocks</emphasis>, and JavaScript <emphasis>reaches</emphasis>.</simpara>
</blockquote>
<simpara><emphasis>ClojureScript</emphasis> is an implementation of the Clojure programming language that
targets JavaScript. Because of this, it can run in many different execution
environments including web browsers, Node.js, Nashorn (and many other).</simpara>
<simpara>Unlike other languages that intend to <emphasis>compile</emphasis> to JavaScript (like TypeScript,
FunScript, or CoffeeScript), ClojureScript is designed to use JavaScript like
bytecode.  It embraces functional programming and has very safe and consistent
defaults. Its semantics differ significantly from those of JavaScript.</simpara>
<simpara>Another big difference (and in our opinion an advantage) over other languages is
that Clojure(Script) is designed to be a guest. It is a language without its own
virtual machine that can be easily adapted to the nuances of its execution
environment. This has the benefit that Clojure (and hence ClojureScript) has
access to all the existing libraries written for the host language.</simpara>
<simpara>Before we jump in, let us summarize some of the core ideas that ClojureScript
brings to the table. Don&#8217;t worry if you don&#8217;t understand all of them right now,
they&#8217;ll become clear throughout the book.</simpara>
<itemizedlist>
<listitem>
<simpara>ClojureScript enforces the functional programming paradigm with its design
decisions and idioms. Although being strongly opinionated about functional
programming it&#8217;s a pragmatic language rather than pursuing theoretical purity.</simpara>
</listitem>
<listitem>
<simpara>Encourages programming with immutable data, offering highly performant and
state of the art immutable collection implementations.</simpara>
</listitem>
<listitem>
<simpara>It makes a clear distinction of identity and its state, with explicit constructs
for managing change as a series of immutable values over time.</simpara>
</listitem>
<listitem>
<simpara>It has type-based and value-based polymorphism, elegantly solving the expression
problem.</simpara>
</listitem>
<listitem>
<simpara>It is a Lisp dialect so programs are written in the programming language&#8217;s own
data structures, a property known as <emphasis>homoiconicity</emphasis> that makes metaprogramming
(programs that write programs) as simple as it can be.</simpara>
</listitem>
</itemizedlist>
<simpara>These ideas together have a great influence in the way you design and implement
software, even if you are not using ClojureScript. Functional programming,
decoupling of data (which is immutable) from the operations to transform it,
explicit idioms for managing change over time and polymorphic constructs for
programming to abstractions greatly simplify the systems we write.</simpara>
<blockquote>
<attribution>
Rich Hickey
</attribution>
<simpara>We can make the same exact software we are making today with dramatically
simpler stuff — dramatically simpler languages, tools, techniques, approaches.</simpara>
</blockquote>
<simpara>We hope you enjoy the book and ClojureScript brings the same joy and inspiration that
has brought to us.</simpara>
</chapter>
<chapter id="language-the-basics">
<title>Language (the basics)</title>
<simpara>This chapter will be a little introduction to ClojureScript without assumptions about
previous knowledge of the Clojure language, providing a quick tour over all the
things you will need to know about ClojureScript and understand the rest of this
book.</simpara>
<simpara>You can run the code snippets in the online interactive repl:
<ulink url="http://www.clojurescript.io/">http://www.clojurescript.io/</ulink></simpara>
<section id="first-steps-with-lisp-syntax">
<title>First steps with Lisp syntax</title>
<simpara>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages
that is still around. It has evolved into many derivatives called dialects,
ClojureScript being one of them. It is a programming language written in its own
data structures — originally lists enclosed in parentheses — but Clojure(Script) has
evolved the Lisp syntax with more data structures, making it more pleasant to write
and read.</simpara>
<simpara>A list with a function in the first position is used for calling a function in
ClojureScript. In the example below, we apply the addition function to three
arguments. Note that unlike in other languages, <literal>+</literal> is not an operator but a
function. Lisp has no operators; it only has functions.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>In the example above, we&#8217;re applying the addition function <literal>+</literal> to the arguments <literal>1</literal>,
<literal>2</literal> and <literal>3</literal>. ClojureScript allows many unusual characters like <literal>?</literal> or <literal>-</literal> in symbol
names, which makes it easier to read:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(zero? 0)
;; =&gt; true</programlisting>
<simpara>To distinguish function calls from lists of data items, we can quote lists to keep
them from being evaluated.  The quoted lists will be treated as data instead of as a
function call:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(+ 1 2 3)
;; =&gt; (+ 1 2 3)</programlisting>
<simpara>ClojureScript uses more than lists for its syntax. The full details will be covered
later, but here is an example of the usage of a vector (enclosed in brackets) for
defining local bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x 1
      y 2
      z 3]
  (+ x y z))
;; =&gt; 6</programlisting>
<simpara>This is practically all the syntax we need to know for using not only ClojureScript,
but any Lisp. Being written in its own data structures (often referred to as
<emphasis>homoiconicity</emphasis>) is a great property since the syntax is uniform and simple; also,
code generation via <link linkend="macros-section">macros</link> is easier than in any other
language, giving us plenty of power to extend the language to suit our needs.</simpara>
</section>
<section id="the-base-data-types">
<title>The base data types</title>
<simpara>The ClojureScript language has a rich set of data types like most programming
languages. It provides scalar data types that will be very familiar to you, such as
numbers, strings, and floats. Beyond these, it also provides a great number of
others that might be less familiar, such as symbols, keywords, regexes (regular
expressions), vars, atoms, and volatiles.</simpara>
<simpara><emphasis>ClojureScript</emphasis> embraces the host language, and where possible, uses the host&#8217;s
provided types. For example: numbers and strings are used as is and behave in the
same way as in JavaScript.</simpara>
<section id="numbers">
<title>Numbers</title>
<simpara>In <emphasis>ClojureScript</emphasis>, numbers include both integers and floating points. Keeping in
mind that <emphasis>ClojureScript</emphasis> is a guest language that compiles to JavaScript, integers
are actually JavaScript&#8217;s native floating points under the hood.</simpara>
<simpara>As in any other language, numbers in <emphasis>ClojureScript</emphasis> are represented in the
following ways:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4</programlisting>
</section>
<section id="keywords">
<title>Keywords</title>
<simpara>Keywords in <emphasis>ClojureScript</emphasis> are objects that always evaluate to themselves. They are
usually used in <link linkend="maps-section">map data structures</link> to efficiently represent the
keys.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">:foobar
:2
:?</programlisting>
<simpara>As you can see, the keywords are all prefixed with <literal>:</literal>, but this character is
only part of the literal syntax and is not part of the name of the object.</simpara>
<simpara>You can also create a keyword by calling the <literal>keyword</literal> function. Don&#8217;t worry if
you don&#8217;t understand or are unclear about anything in the following example;
<link linkend="function-section">functions</link> are discussed in a later section.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(keyword "foo")
;; =&gt; :foo</programlisting>
<section id="namespaced-keywords">
<title>Namespaced keywords</title>
<simpara>When prefixing keywords with a double colon <literal>::</literal>, the keyword will be prepended
by the name of the current namespace.  Note that namespacing keywords affects
equality comparisons.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">::foo
;; =&gt; :cljs.user/foo

(= ::foo :foo)
;; =&gt; false</programlisting>
<simpara>Another alternative is to include the namespace in the keyword
literal, this is useful when creating namespaced keywords for other
namespaces:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">:cljs.unraveled/foo
;; =&gt; :cljs.unraveled/foo</programlisting>
<simpara>The <literal>keyword</literal> function has an arity-2 variant where we can specify the namespace as the first parameter:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(keyword "cljs.unraveled" "foo")
;; =&gt; :cljs.unraveled/foo</programlisting>
</section>
</section>
<section id="symbols">
<title>Symbols</title>
<simpara>Symbols in <emphasis>ClojureScript</emphasis> are very, very similar to <emphasis role="strong">keywords</emphasis> (which you now know
about). But instead of evaluating to themselves, symbols are evaluated to something
that they refer to, which can be functions, variables, etc.</simpara>
<simpara>Symbols start with a non numeric character and can contain alphanumeric characters
as well as *, +, !, -, _, ', and ? such as :</simpara>
<programlisting language="clojure" linenumbering="unnumbered">sample-symbol
othersymbol
f1
my-special-swap!</programlisting>
<simpara>Don&#8217;t worry if you don&#8217;t understand right away; symbols are used in almost all of
our examples, which will give you the opportunity to learn more as we go on.</simpara>
</section>
<section id="strings">
<title>Strings</title>
<simpara>There is almost nothing new we can explain about strings that you don&#8217;t already
know. In <emphasis>ClojureScript</emphasis>, they work the same as in any other language. One point of
interest, however, is that they are immutable.</simpara>
<simpara>In this case they are the same as in JavaScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"An example of a string"</programlisting>
<simpara>One peculiar aspect of strings in <emphasis>ClojureScript</emphasis> is due to the language&#8217;s Lisp
syntax: single and multiline strings have the same syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"This is a multiline
      string in ClojureScript."</programlisting>
</section>
<section id="characters">
<title>Characters</title>
<simpara><emphasis>ClojureScript</emphasis> also lets you write single characters using Clojure&#8217;s character
literal syntax.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">\a        ; The lowercase a character
\newline  ; The newline character</programlisting>
<simpara>Since the host language doesn&#8217;t contain character literals, <emphasis>ClojureScript</emphasis>
characters are transformed behind the scenes into single character JavaScript
strings.</simpara>
</section>
<section id="collections">
<title>Collections</title>
<simpara>Another big step in explaining a language is to explain its collections and
collection abstractions. <emphasis>ClojureScript</emphasis> is not an exception to this rule.</simpara>
<simpara><emphasis>ClojureScript</emphasis> comes with many types of collections. The main difference between
<emphasis>ClojureScript</emphasis> collections and collections in other languages is that they are
persistent and immutable.</simpara>
<simpara>Before moving on to these (possibly) unknown concepts, we&#8217;ll present a high-level
overview of existing collection types in <emphasis>ClojureScript</emphasis>.</simpara>
<section id="lists">
<title>Lists</title>
<simpara>This is a classic collection type in languages based on Lisp. Lists are the simplest
type of collection in <emphasis>ClojureScript</emphasis>. Lists can contain items of any type,
including other collections.</simpara>
<simpara>Lists in <emphasis>ClojureScript</emphasis> are represented by items enclosed between parentheses:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(1 2 3 4 5)
'(:foo :bar 2)</programlisting>
<simpara>As you can see, all list examples are prefixed with the <literal>'</literal> char. This is because
lists in Lisp-like languages are often used to express things like function or macro
calls. In that case, the first item should be a symbol that will evaluate to
something callable, and the rest of the list elements will be function
arguments. However, in the preceding examples, we don&#8217;t want the first item as a
symbol; we just want a list of items.</simpara>
<simpara>The following example shows the difference between a list without and with the
preceding single quote mark:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2

'(inc 1)
;; =&gt; (inc 1)</programlisting>
<simpara>As you can see, if you evaluate <literal>(inc 1)</literal> without prefixing it with <literal>'</literal>, it will
resolve the <literal>inc</literal> symbol to the <emphasis role="strong">inc</emphasis> function and will execute it with <literal>1</literal> as the
first argument, returning the value <literal>2</literal>.</simpara>
<simpara>You can also explicitly create a list with the <literal>list</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(list 1 2 3 4 5)
;; =&gt; (1 2 3 4 5)

(list :foo :bar 2)
;; =&gt; (:foo :bar 2)</programlisting>
<simpara>Lists have the peculiarity that they are very efficient if you access them
sequentially or access their first elements, but a list is not a very good option if
you need random (index) access to its elements.</simpara>
</section>
<section id="vectors">
<title>Vectors</title>
<simpara>Like lists, <emphasis role="strong">vectors</emphasis> store a series of values, but in this case, with very
efficient index access to their elements, as opposed to lists, which are evaluated
in order. Don&#8217;t worry; in the following sections we&#8217;ll go in depth with details, but
at this moment, this simple explanation is more than enough.</simpara>
<simpara>Vectors use square brackets for the literal syntax; let&#8217;s see some examples:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">[:foo :bar]
[3 4 5 nil]</programlisting>
<simpara>Like lists, vectors can contain objects of any type, as you can observe in the
preceding example.</simpara>
<simpara>You can also explicitly create a vector with the <literal>vector</literal> function, but this is not
commonly used in ClojureScript programs:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(vector 1 2 3)
;; =&gt; [1 2 3]

(vector "blah" 3.5 nil)
;; =&gt; ["blah" 3.5 nil]</programlisting>
</section>
<section id="maps-section">
<title>Maps</title>
<simpara>Maps are a collection abstraction that allow you to store key/value pairs. In other
languages, this type of structure is commonly known as a hash-map or dict
(dictionary). Map literals in <emphasis>ClojureScript</emphasis> are written with the pairs between
curly braces.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:foo "bar", :baz 2}
{:alphabet [:a :b :c]}</programlisting>
<note>
<simpara>Commas are frequently used to separate a key-value pair, but they are
completely optional. In <emphasis>ClojureScript</emphasis> syntax, commas are treated like spaces.</simpara>
</note>
<simpara>Like vectors, every item in a map literal is evaluated before the result is stored
in a map, but the order of evaluation is not guaranteed.</simpara>
</section>
<section id="sets">
<title>Sets</title>
<simpara>And finally, <emphasis role="strong">sets</emphasis>.</simpara>
<simpara>Sets store zero or more unique items of any type and are unordered. Like maps, they
use curly braces for their literal syntax, with the difference being that they use a
<literal>#</literal> as the leading character. You can also use the <literal>set</literal> function to convert a
collection to a set:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#{1 2 3 :foo :bar}
;; =&gt; #{1 :bar 3 :foo 2}
(set [1 2 1 3 1 4 1 5])
;; =&gt; #{1 2 3 4 5}</programlisting>
<simpara>In subsequent sections, we&#8217;ll go in depth about sets and the other collection types
you&#8217;ve seen in this section.</simpara>
</section>
</section>
</section>
<section id="vars">
<title>Vars</title>
<simpara><emphasis>ClojureScript</emphasis> is a mostly functional language that focuses on
immutability. Because of that, it does not have the concept of variables as you know
them in most other programming languages. The closest analogy to variables are the
variables you define in algebra; when you say <literal>x = 6</literal> in mathematics, you are saying
that you want the symbol <literal>x</literal> to stand for the number six.</simpara>
<simpara>In <emphasis>ClojureScript</emphasis>, vars are represented by symbols and store a single value
together with metadata.</simpara>
<simpara>You can define a var using the <literal>def</literal> special form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x 22)
(def y [1 2 3])</programlisting>
<simpara>Vars are always top level in the namespace (<link linkend="namespace-section">which we will
explain later</link>). If you use <literal>def</literal> in a function call, the var will be defined at
the namespace level, but we do not recommend this - instead, you should use <literal>let</literal> to
define variables within a function.</simpara>
</section>
<section id="function-section">
<title>Functions</title>
<section id="the-first-contact">
<title>The first contact</title>
<simpara>It&#8217;s time to make things happen. <emphasis>ClojureScript</emphasis> has what are known as first class
functions. They behave like any other type; you can pass them as parameters and you
can return them as values, always respecting the lexical scope. <emphasis>ClojureScript</emphasis> also
has some features of dynamic scoping, but this will be discussed in another section.</simpara>
<simpara>If you want to know more about scopes, this
<ulink url="http://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia article</ulink> is
very extensive and explains different types of scoping.</simpara>
<simpara>As <emphasis>ClojureScript</emphasis> is a Lisp dialect, it uses the prefix notation for calling a
function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2</programlisting>
<simpara>In the example above, <literal>inc</literal> is a function and is part of the <emphasis>ClojureScript</emphasis>
runtime, and <literal>1</literal> is the first argument for the <literal>inc</literal> function.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>The <literal>+</literal> symbol represents an <literal>add</literal> function. It allows multiple parameters, whereas
in ALGOL-type languages, <literal>+</literal> is an operator and only allows two parameters.</simpara>
<simpara>The prefix notation has huge advantages, some of them not always
obvious. <emphasis>ClojureScript</emphasis> does not make a distinction between a function and an
operator; everything is a function. The immediate advantage is that the prefix
notation allows an arbitrary number of arguments per "operator". It also completely
eliminates the problem of operator precedence.</simpara>
</section>
<section id="defining-your-own-functions">
<title>Defining your own functions</title>
<simpara>You can define an unnamed (anonymous) function with the <literal>fn</literal> special form. This is
one type of function definition; in the following example, the function takes two
parameters and returns their average.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(fn [param1 param2]
  (/ (+ param1 param2) 2.0))</programlisting>
<simpara>You can define a function and call it at the same time (in a single expression):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">((fn [x] (* x x)) 5)
;; =&gt; 25</programlisting>
<simpara>Let&#8217;s start creating named functions. But what does a <emphasis>named function</emphasis> really mean?
It is very simple; in <emphasis>ClojureScript</emphasis>, functions are first-class and behave like any
other value, so naming a function is done by simply binding the function to a
symbol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def square (fn [x] (* x x)))

(square 12)
;; =&gt; 144</programlisting>
<simpara><emphasis>ClojureScript</emphasis> also offers the <literal>defn</literal> macro as a little syntactic sugar for making
function definition more idiomatic:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn square
  "Return the square of a given number."
  [x]
  (* x x))</programlisting>
<simpara>The string that comes between the function name and the parameter vector is called a
<emphasis>docstring</emphasis> (documentation string); programs that automatically create web
documentation from your source files will use these docstrings.</simpara>
</section>
<section id="functions-with-multiple-arities">
<title>Functions with multiple arities</title>
<simpara><emphasis>ClojureScript</emphasis> also comes with the ability to define functions with an arbitrary
number of arguments. (The term <emphasis>arity</emphasis> means the number of arguments that a function
takes.) The syntax is almost the same as for defining an ordinary function, with the
difference that it has more than one body.</simpara>
<simpara>Let&#8217;s see an example, which will explain it better:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn myinc
  "Self defined version of parameterized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))</programlisting>
<simpara>This line: <literal>([x] (myinc x 1))</literal> says that if there is only one argument, call the
function <literal>myinc</literal> with that argument and the number <literal>1</literal> as the second argument. The
other function body <literal>([x increment] (+ x increment))</literal> says that if there are two
arguments, return the result of adding them.</simpara>
<simpara>Here are some examples using the previously defined multi-arity function. Observe
that if you call a function with the wrong number of arguments, the compiler will
emit an error message.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(myinc 1)
;; =&gt; 2

(myinc 1 3)
;; =&gt; 4

(myinc 1 3 3)
;; Compiler error</programlisting>
<note>
<simpara>Explaining the concept of "arity" is out of the scope of this book, however
you can read about that in this <ulink url="http://en.wikipedia.org/wiki/Arity">Wikipedia
article</ulink>.</simpara>
</note>
</section>
<section id="variadic-functions">
<title>Variadic functions</title>
<simpara>Another way to accept multiple parameters is defining variadic functions. Variadic
functions are functions that accept an arbitrary number of arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-variadic-set
  [&amp; params]
  (set params))

(my-variadic-set 1 2 3 1)
;; =&gt; #{1 2 3}</programlisting>
<simpara>The way to denote a variadic function is using the <literal>&amp;</literal> symbol prefix on its
arguments vector.</simpara>
</section>
<section id="short-syntax-for-anonymous-functions">
<title>Short syntax for anonymous functions</title>
<simpara><emphasis>ClojureScript</emphasis> provides a shorter syntax for defining anonymous functions using the
<literal>#()</literal> reader macro (usually leads to one-liners). Reader macros are "special"
expressions that will be transformed to the appropriate language form at compile
time; in this case, to some expression that uses the <literal>fn</literal> special form.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def average #(/ (+ %1 %2) 2))

(average 3 4)
;; =&gt; 3.5</programlisting>
<simpara>The preceding definition is shorthand for:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def average-longer (fn [a b] (/ (+ a b) 2)))

(average-longer 7 8)
;; =&gt; 7.5</programlisting>
<simpara>The <literal>%1</literal>, <literal>%2</literal>&#8230;&#8203; <literal>%N</literal> are simple markers for parameter positions that are
implicitly declared when the reader macro will be interpreted and converted to a
<literal>fn</literal> expression.</simpara>
<simpara>If a function only accepts one argument, you can omit the number after the <literal>%</literal>
symbol, e.g., a function that squares a number: <literal>#(* %1 %1))</literal> can be written
<literal>#(* % %))</literal>.</simpara>
<simpara>Additionally, this syntax also supports the variadic form with the <literal>%&amp;</literal> symbol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-variadic-set #(set %&amp;))

(my-variadic-set 1 2 2)
;; =&gt; #{1 2}</programlisting>
</section>
</section>
<section id="flow-control">
<title>Flow control</title>
<simpara><emphasis>ClojureScript</emphasis> has a very different approach to flow control than languages like
JavaScript, C, etc.</simpara>
<section id="branching-with-if">
<title>Branching with <literal>if</literal></title>
<simpara>Let&#8217;s start with a basic one: <literal>if</literal>. In <emphasis>ClojureScript</emphasis>, the <literal>if</literal> is an expression
and not a statement, and it has three parameters: the first one is the condition
expression, the second one is an expression that will be evaluated if the condition
expression evaluates to logical true, and the third expression will be evaluated
otherwise.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn discount
  "You get 5% discount for ordering 100 or more items"
  [quantity]
  (if (&gt;= quantity 100)
    0.05
    0))

(discount 30)
;; =&gt; 0

(discount 130)
;; =&gt; 0.05</programlisting>
<simpara>The block expression <literal>do</literal> can be used to have multiple expressions in an <literal>if</literal>
branch.  <link linkend="block-section"><literal>do</literal> is explained in the next section</link>.</simpara>
</section>
<section id="branching-with-cond">
<title>Branching with <literal>cond</literal></title>
<simpara>Sometimes, the <literal>if</literal> expression can be slightly limiting because it does not have the
"else if" part to add more than one condition. The <literal>cond</literal> macro comes to the rescue.</simpara>
<simpara>With the <literal>cond</literal> expression, you can define multiple conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn mypos?
  [x]
  (cond
    (&gt; x 0) "positive"
    (&lt; x 0) "negative"
    :else "zero"))

(mypos? 0)
;; =&gt; "zero"

(mypos? -2)
;; =&gt; "negative"</programlisting>
<simpara>Also, <literal>cond</literal> has another form, called <literal>condp</literal>, that works very similarly to the
simple <literal>cond</literal> but looks cleaner when the condition (also called a predicate) is the
same for all conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
<simpara>The line <literal>condp = (keyword code)</literal> means that, in each of the following lines,
<emphasis>ClojureScript</emphasis> will apply the <literal>=</literal> function to the result of evaluating <literal>(keyword
code)</literal>.</simpara>
</section>
<section id="branching-with-case">
<title>Branching with <literal>case</literal></title>
<simpara>The <literal>case</literal> branching expression has a similar use as our previous example with
<literal>condp</literal>. The main differences are that <literal>case</literal> always uses the <literal>=</literal> predicate/function
and its branching values are evaluated at compile time. This results in a more
performant form than <literal>cond</literal> or <literal>condp</literal> but has the disadvantage that the condition
value must be static.</simpara>
<simpara>Here is the previous example rewritten to use <literal>case</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "en" "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
</section>
</section>
<section id="truthiness-section">
<title>Truthiness</title>
<simpara>This is the aspect where each language has its own semantics (mostly wrongly). The
majority of languages consider empty collections, the integer 0, and other things
like this to be false.  In <emphasis>ClojureScript</emphasis>, unlike in other languages, only two
values are considered as false: <literal>nil</literal> and <literal>false</literal>. Everything else is treated as
logical <literal>true</literal>.</simpara>
<simpara>Jointly with the ability to implement the callable protocol (the <literal>IFn</literal>, explained
more in detail later), data structures like sets can be used just as predicates,
without need of additional wrapping them in a function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def valid? #{1 2 3})

(filter valid? (range 1 10))
;; =&gt; (1 2 3)</programlisting>
<simpara>This works because a set returns either the value itself for all contained elements
or <literal>nil</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(valid? 1)
;; =&gt; 1

(valid? 4)
;; =&gt; nil</programlisting>
</section>
<section id="locals-blocks-and-loops">
<title>Locals, Blocks, and Loops</title>
<section id="locals">
<title>Locals</title>
<simpara><emphasis>ClojureScript</emphasis> does not have the concept of variables as in ALGOL-like languages,
but it does have locals. Locals, as per usual, are immutable, and if you try to
mutate them, the compiler will throw an error.</simpara>
<simpara>Locals are defined with the <literal>let</literal> expression. The expression starts with a vector as
the first parameter followed by an arbitrary number of expressions. The first
parameter (the vector) should contain an arbitrary number of pairs that give a
<emphasis>binding form</emphasis> (usually a symbol) followed by an expression whose value will be
bound to this new local for the remainder of the <literal>let</literal> expression.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from the body of a let")
  (* x y))
;; Simple message from the body of a let
;; =&gt; 6</programlisting>
<simpara>In the preceding example, the symbol <literal>x</literal> is bound to the value <literal>(inc 1)</literal>, which
comes out to 2, and the symbol <literal>y</literal> is bound to the sum of <literal>x</literal> and 1, which comes out
to 3. Given those bindings, the expressions <literal>(println "Simple message from the body
of a let")</literal> and <literal>(* x y)</literal> are evaluated.</simpara>
</section>
<section id="blocks">
<title>Blocks</title>
<simpara>In JavaScript, braces <literal>{</literal> and <literal>}</literal> delimit a block of code that “belongs
together”. Blocks in <emphasis>ClojureScript</emphasis> are created using the <literal>do</literal> expression and are
usually used for side effects, like printing something to the console or writing a
log in a logger.</simpara>
<simpara>A side effect is something that is not necessary for the return value.</simpara>
<simpara>The <literal>do</literal> expression accepts as its parameter an arbitrary number of other
expressions, but it returns the return value only from the last one:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(do
  (println "hello world")
  (println "hola mundo")
  (* 3 5) ;; this value will not be returned; it is thrown away
  (+ 1 2))

;; hello world
;; hola mundo
;; =&gt; 3</programlisting>
<simpara>The body of the <literal>let</literal> expression, explained in the previous section, is very similar
to the <literal>do</literal> expression in that it allows multiple expressions. In fact, the <literal>let</literal>
has an implicit <literal>do</literal>.</simpara>
</section>
<section id="loops">
<title>Loops</title>
<simpara>The functional approach of <emphasis>ClojureScript</emphasis> means that it does not have standard,
well-known, statement-based loops such as <literal>for</literal> in JavaScript. The loops in
<emphasis>ClojureScript</emphasis> are handled using recursion.  Recursion sometimes requires
additional thinking about how to model your problem in a slightly different way than
imperative languages.</simpara>
<simpara>Many of the common patterns for which <literal>for</literal> is used in other languages are achieved
through higher-order functions - functions that accept other functions as
parameters.</simpara>
<section id="looping-with-looprecur">
<title>Looping with loop/recur</title>
<simpara>Let&#8217;s take a look at how to express loops using recursion with the <literal>loop</literal> and
<literal>recur</literal> forms.  <literal>loop</literal> defines a possibly empty list of bindings (notice the
symmetry with <literal>let</literal>) and <literal>recur</literal> jumps execution back to the looping point with new
values for those bindings.</simpara>
<simpara>Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(loop [x 0]
  (println "Looping with " x)
  (if (= x 2)
    (println "Done looping!")
    (recur (inc x))))
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
<simpara>In the above snippet, we bind the name <literal>x</literal> to the value <literal>0</literal> and execute the
body. Since the condition is not met the first time, it&#8217;s rerun with <literal>recur</literal>,
incrementing the binding value with the <literal>inc</literal> function. We do this once more until
the condition is met and, since there aren&#8217;t any more <literal>recur</literal> calls, exit the loop.</simpara>
<simpara>Note that <literal>loop</literal> isn&#8217;t the only point we can <literal>recur</literal> to; using <literal>recur</literal> inside a
function executes the body of the function recursively with the new bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn recursive-function
  [x]
  (println "Looping with" x)
  (if (= x 2)
    (println "Done looping!")
    (recur (inc x))))

(recursive-function 0)
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
</section>
<section id="replacing-for-loops-with-higher-order-functions">
<title>Replacing for loops with higher-order functions</title>
<simpara>In imperative programming languages it is common to use <literal>for</literal> loops to iterate over
data and transform it, usually with the intent being one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Transform every value in the iterable yielding another iterable</simpara>
</listitem>
<listitem>
<simpara>Filter the elements of the iterable by certain criteria</simpara>
</listitem>
<listitem>
<simpara>Convert the iterable to a value where each iteration depends on the result from
the previous one</simpara>
</listitem>
<listitem>
<simpara>Run a computation for every value in the iterable</simpara>
</listitem>
</itemizedlist>
<simpara>The above actions are encoded in higher-order functions and syntactic constructs in
ClojureScript; let&#8217;s see an example of the first three.</simpara>
<simpara>For transforming every value in an iterable data structure we use the <literal>map</literal>
function, which takes a function and a sequence and applies the function to every
element:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [0 1 2])
;; =&gt; (1 2 3)</programlisting>
<simpara>The first parameter for <literal>map</literal> can be <emphasis>any</emphasis> function that takes one argument and
returns a value.  For example, if you had a graphing application and you wanted to
graph the equation <literal>y&#160;=&#160;3x&#160;+&#160;5</literal> for a set of <emphasis>x</emphasis> values, you
could get the <emphasis>y</emphasis> values like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn y-value [x] (+ (* 3 x) 5))

(map y-value [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)</programlisting>
<simpara>If your function is short, you can use an anonymous function instead, either the
normal or short syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map (fn [x] (+ (* 3 x) 5)) [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)

(map #(+ (* 3 %) 5) [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)</programlisting>
<simpara>For filtering the values of a data structure we use the <literal>filter</literal> function, which
takes a predicate and a sequence and gives a new sequence with only the elements
that returned <literal>true</literal> for the given predicate:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter odd? [1 2 3 4])
;; =&gt; (1 3)</programlisting>
<simpara>Again, you can use any function that returns <literal>true</literal> or <literal>false</literal> as the first argument
to <literal>filter</literal>.  Here is an example that keeps only words less than five characters
long. (The <literal>count</literal> function returns the length of its argument.)</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter (fn [word] (&lt; (count word) 5)) ["ant" "baboon" "crab" "duck" "echidna" "fox"])
;; =&gt; ("ant" "crab" "duck" "fox")</programlisting>
<simpara>Converting an iterable to a single value, accumulating the intermediate result at
every step of the iteration can be achieved with <literal>reduce</literal>, which takes a function
for accumulating values, an optional initial value and a collection:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce + 0 [1 2 3 4])
;; =&gt; 10</programlisting>
<simpara>Yet again, you can provide your own function as the first argument to <literal>reduce</literal>, but
your function must have <emphasis>two</emphasis> parameters. The first one is the "accumulated value"
and the second parameter is the collection item being processed. The function
returns a value that becomes the accumulator for the next item in the list.  For
example, here is how you would find the sum of squares of a set of numbers (this is
an important calculation in statistics). Using a separate function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn sum-squares
  [accumulator item]
  (+ accumulator (* item item)))

(reduce sum-squares 0 [3 4 5])
;; =&gt; 50</programlisting>
<simpara>&#8230;&#8203;and with an anonymous function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce (fn [acc item] (+ acc (* item item))) 0 [3 4 5])
;; =&gt; 50</programlisting>
<simpara>Here is a <literal>reduce</literal> that finds the total number of characters in a set of words:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce (fn [acc word] (+ acc (count word))) 0 ["ant" "bee" "crab" "duck"])
;; =&gt; 14</programlisting>
<simpara>We have not used the short syntax here because, although it requires less typing, it
can be less readable, and when you are starting with a new language, it&#8217;s important
to be able to read what you wrote! If you are comfortable with the short syntax,
feel free to use it.</simpara>
<simpara>Remember to choose your starting value for the accumulator carefully. If you wanted
to use <literal>reduce</literal> to find the product of a series of numbers, you would have to start
with one rather than zero, otherwise all the numbers would be multiplied by zero!</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; wrong starting value
(reduce * 0 [3 4 5])
;; =&gt; 0

;; correct starting accumulator
(reduce * 1 [3 4 5])
;; =&gt; 60</programlisting>
</section>
<section id="for-sequence-comprehensions">
<title><literal>for</literal> sequence comprehensions</title>
<simpara>In ClojureScript, the <literal>for</literal> construct isn&#8217;t used for iteration but for generating
sequences, an operation also known as "sequence comprehension". In this section
we&#8217;ll learn how it works and use it to declaratively build sequences.</simpara>
<simpara><literal>for</literal> takes a vector of bindings and an expression and generates a sequence of the
result of evaluating the expression. Let&#8217;s take a look at an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]]
  [x (* x x)])
;; =&gt; ([1 1] [2 4] [3 9])</programlisting>
<simpara>In this example, <literal>x</literal> is bound to each of the items in the vector <literal>[1 2 3]</literal> in turn,
and returns a new sequence of two-item vectors with the original item squared.</simpara>
<simpara><literal>for</literal> supports multiple bindings, which will cause the collections to be iterated in
a nested fashion, much like nesting <literal>for</literal> loops in imperative languages. The
innermost binding iterates “fastest.”</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]]
  [x y])

;; =&gt; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</programlisting>
<simpara>We can also follow the bindings with three modifiers: <literal>:let</literal> for creating local
bindings, <literal>:while</literal> for breaking out of the sequence generation, and <literal>:when</literal> for
filtering out values.</simpara>
<simpara>Here&#8217;s an example of local bindings using the <literal>:let</literal> modifier; note that the
bindings defined with it will be available in the expression:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; =&gt; (5 6 6 7 7 8)</programlisting>
<simpara>We can use the <literal>:while</literal> modifier for expressing a condition that, when it is no
longer met, will stop the sequence generation. Here&#8217;s an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])

;; =&gt; ([1 4] [2 4] [3 4])</programlisting>
<simpara>For filtering out generated values, use the <literal>:when</literal> modifier as in the following
example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])

;; =&gt; ([1 5] [2 4])</programlisting>
<simpara>We can combine the modifiers shown above for expressing complex sequence generations
or more clearly expressing the intent of our comprehension:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])

;; =&gt; ([1 5] [2 4])</programlisting>
<simpara>When we outlined the most common usages of the <literal>for</literal> construct in imperative
programming languages, we mentioned that sometimes we want to run a computation for
every value in a sequence, not caring about the result. Presumably we do this for
achieving some sort of side-effect with the values of the sequence.</simpara>
<simpara>ClojureScript provides the <literal>doseq</literal> construct, which is analogous to <literal>for</literal> but
executes the expression, discards the resulting values, and returns <literal>nil</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))

;; 1 + 4 = 5
;; 1 + 5 = 6
;; 2 + 4 = 6
;; 2 + 5 = 7
;; 3 + 4 = 7
;; 3 + 5 = 8
;; =&gt; nil</programlisting>
<simpara>If you want just iterate and apply some side effectfull operation (like <literal>println</literal>)
over each item in the collection, you can just use the specialized function <literal>run!</literal>
that internally uses fast reduction:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(run! println [1 2 3])
;; 1
;; 2
;; 3
;; =&gt; nil</programlisting>
<simpara>This function explicitly returns <literal>nil</literal>.</simpara>
</section>
</section>
</section>
<section id="collection-types">
<title>Collection types</title>
<section id="immutable-and-persistent">
<title>Immutable and persistent</title>
<simpara>We mentioned before that ClojureScript collections are persistent and immutable, but
we didn&#8217;t explain what that meant.</simpara>
<simpara>An immutable data structure, as its name suggests, is a data structure that cannot
be changed. In-place updates are not allowed in immutable data structures.</simpara>
<simpara>Let&#8217;s illustrate that with an example: appending values to a vector using the <literal>conj</literal>
(conjoin) operation.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))

;; xs: [1 2 3]
;; ys: [1 2 3 4]
;; =&gt; nil</programlisting>
<simpara>As you can see, we derived a new version of the <literal>xs</literal> vector appending an element
to it and got a new vector <literal>ys</literal> with the element added. However, the <literal>xs</literal> vector
remained unchanged because it is immutable.</simpara>
<simpara>A persistent data structure is a data structure that returns a new version of
itself when transforming it, leaving the original unmodified. ClojureScript makes
this memory and time efficient using an implementation technique called <emphasis>structural
sharing</emphasis>, where most of the data shared between two versions of a value is not
duplicated and transformations of a value are implemented by copying the minimal
amount of data required.</simpara>
<simpara>If you want to see an example of how structural sharing works, read on. If you&#8217;re
not interested in more details you can skip over to the
<link linkend="the-sequence-abstraction">next section</link>.</simpara>
<simpara>For illustrating the structural sharing of ClojureScript data structures, let&#8217;s
compare whether some parts of the old and new versions of a data structure are
actually the same object with the <literal>identical?</literal> predicate. We&#8217;ll use the list data
type for this purpose:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))

;; xs: (1 2 3)
;; ys: (0 1 2 3)
;; (rest ys): (1 2 3)
;; =&gt; true</programlisting>
<simpara>As you can see in the example, we used <literal>cons</literal> (construct) to prepend a value to
the <literal>xs</literal> list and we got a new list <literal>ys</literal> with the element added. The <literal>rest</literal> of
the <literal>ys</literal> list (all the values but the first) are the same object in memory as the
<literal>xs</literal> list, thus <literal>xs</literal> and <literal>ys</literal> share structure.</simpara>
</section>
<section id="the-sequence-abstraction">
<title>The sequence abstraction</title>
<simpara>One of the central ClojureScript abstractions is the <emphasis>sequence</emphasis> which can be
thought of as a list and can be derived from any of the collection types. It is
persistent and immutable like all collection types, and many of the core
ClojureScript functions return sequences.</simpara>
<simpara>The types that can be used to generate a sequence are called "seqables"; we can
call <literal>seq</literal> on them and get a sequence back. Sequences support two basic operations:
<literal>first</literal> and <literal>rest</literal>. They both call <literal>seq</literal> on the argument we provide them:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(first [1 2 3])
;; =&gt; 1

(rest [1 2 3])
;; =&gt; (2 3)</programlisting>
<simpara>Calling <literal>seq</literal> on a seqable can yield different results if the seqable is empty or
not. It will return <literal>nil</literal> when empty and a sequence otherwise:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq [])
;; =&gt; nil

(seq [1 2 3])
;; =&gt; (1 2 3)</programlisting>
<simpara><literal>next</literal> is a similar sequence operation to <literal>rest</literal>, but it differs from the latter
in that it yields a <literal>nil</literal> value when called with a sequence with one or zero
elements. Note that, when given one of the aforementioned sequences, the empty
sequence returned by <literal>rest</literal> will evaluate as a boolean true whereas the <literal>nil</literal>
value returned by <literal>next</literal> will evaluate as false
(<link linkend="truthiness-section">see the section on <emphasis>truthiness</emphasis> later in this chapter</link>).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(rest [])
;; =&gt; ()

(next [])
;; =&gt; nil

(rest [1 2 3])
;; =&gt; (2 3)

(next [1 2 3])
;; =&gt; (2 3)</programlisting>
<section id="nil-punning">
<title>nil-punning</title>
<simpara>Since <literal>seq</literal> returns <literal>nil</literal> when the collection is empty, and <literal>nil</literal> evaluates to
false in boolean context, you can check to see if a collection is empty by using
the <literal>seq</literal> function. The technical term for this is nil-punning.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))

(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; =&gt; nil

(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; =&gt; nil</programlisting>
<simpara>Though <literal>nil</literal> is neither a seqable nor a sequence, it is supported by all the
functions we saw so far:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq nil)
;; =&gt; nil

(first nil)
;; =&gt; nil

(rest nil)
;; =&gt; ()</programlisting>
</section>
<section id="functions-that-work-on-sequences">
<title>Functions that work on sequences</title>
<simpara>The ClojureScript core functions for transforming collections make sequences out
of their arguments and are implemented in terms of the generic sequence operations
we learned about in the preceding section. This makes them highly generic because
we can use them on any data type that is seqable. Let&#8217;s see how we can use <literal>map</literal>
with a variety of seqables:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [1 2 3])
;; =&gt; (2 3 4)

(map inc #{1 2 3})
;; =&gt; (2 4 3)

(map count {:a 41 :b 40})
;; =&gt; (2 2)

(map inc '(1 2 3))
;; =&gt; (2 3 4)</programlisting>
<note>
<simpara>When you use the <literal>map</literal> function on a map collection, your higher-order
function will receive a two-item vector containing a key and value from the map.
The following example uses <link linkend="destructuring-section">destructuring</link> to access
the key and value.</simpara>
</note>
<programlisting language="clojure" linenumbering="unnumbered">(map (fn [[key value]] (* value value))
     {:ten 10 :seven 7 :four 4})
;; =&gt; (100 49 16)</programlisting>
<simpara>Obviously the same operation can be done in more idiomatic way only obtaining a seq
of values:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map (fn [value] (* value value))
     (vals {:ten 10 :seven 7 :four 4}))
;; =&gt; (100 49 16)</programlisting>
<simpara>As you may have noticed, functions that operate on sequences are safe to use with
empty collections or even <literal>nil</literal> values since they don&#8217;t need to do anything but
return an empty sequence when encountering such values.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [])
;; =&gt; ()

(map inc #{})
;; =&gt; ()

(map inc nil)
;; =&gt; ()</programlisting>
<simpara>We already saw examples with the usual suspects like <literal>map</literal>, <literal>filter</literal>, and <literal>reduce</literal>,
but ClojureScript offers a plethora of generic sequence operations in its core
namespace. Note that many of the operations we&#8217;ll learn about either work with
seqables or are extensible to user-defined types.</simpara>
<simpara>We can query a value to know whether it&#8217;s a collection type with the <literal>coll?</literal>
predicate:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(coll? nil)
;; =&gt; false

(coll? [1 2 3])
;; =&gt; true

(coll? {:language "ClojureScript" :file-extension "cljs"})
;; =&gt; true

(coll? "ClojureScript")
;; =&gt; false</programlisting>
<simpara>Similar predicates exist for checking if a value is a sequence (with <literal>seq?</literal>) or a
seqable (with <literal>seqable?</literal>):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq? nil)
;; =&gt; false
(seqable? nil)
;; =&gt; false

(seq? [])
;; =&gt; false
(seqable? [])
;; =&gt; true

(seq? #{1 2 3})
;; =&gt; false
(seqable? #{1 2 3})
;; =&gt; true

(seq? "ClojureScript")
;; =&gt; false
(seqable? "ClojureScript")
;; =&gt; false</programlisting>
<simpara>For collections that can be counted in constant time, we can use the <literal>count</literal>
operation. This operation also works on strings, even though, as you have seen,
they are not collections, sequences, or seqable.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(count nil)
;; =&gt; 0

(count [1 2 3])
;; =&gt; 3

(count {:language "ClojureScript" :file-extension "cljs"})
;; =&gt; 2

(count "ClojureScript")
;; =&gt; 13</programlisting>
<simpara>We can also get an empty variant of a given collection with the <literal>empty</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(empty nil)
;; =&gt; nil

(empty [1 2 3])
;; =&gt; []

(empty #{1 2 3})
;; =&gt; #{}</programlisting>
<simpara>The <literal>empty?</literal> predicate returns true if the given collection is empty:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(empty? nil)
;; =&gt; true

(empty? [])
;; =&gt; true

(empty? #{1 2 3})
;; =&gt; false</programlisting>
<simpara>The <literal>conj</literal> operation adds elements to collections and may add them in different
"places" depending on the type of collection. It adds them where it is most
performant for the collection type, but note that not every collection has a
defined order.</simpara>
<simpara>We can pass as many elements as we want to add to <literal>conj</literal>; let&#8217;s see it in action:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(conj nil 42)
;; =&gt; (42)

(conj [1 2] 3)
;; =&gt; [1 2 3]

(conj [1 2] 3 4 5)
;; =&gt; [1 2 3 4 5]

(conj '(1 2) 0)
;; =&gt; (0 1 2)

(conj #{1 2 3} 4)
;; =&gt; #{1 3 2 4}

(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; =&gt; {:language "ClojureScript", :file-extension "cljs"}</programlisting>
</section>
<section id="laziness">
<title>Laziness</title>
<simpara>Most of ClojureScript&#8217;s sequence-returning functions generate lazy sequences instead
of eagerly creating a whole new sequence. Lazy sequences generate their contents as
they are requested, usually when iterating over them. Laziness ensures that we don&#8217;t
do more work than we need to and gives us the possibility of treating potentially
infinite sequences as regular ones.</simpara>
<simpara>Consider the <literal>range</literal> function, which generates a range of integers:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(range 5)
;; =&gt; (0 1 2 3 4)
(range 1 10)
;; =&gt; (1 2 3 4 5 6 7 8 9)
(range 10 100 15)
;; (10 25 40 55 70 85)</programlisting>
<simpara>If you just say <literal>(range)</literal>, you will get an infinite sequence of all the integers.
Do <emphasis role="strong">not</emphasis> try this in the REPL, unless you are prepared to wait for a very, very long
time, because the REPL wants to fully evaluate the expression.</simpara>
<simpara>Here is a contrived example. Let&#8217;s say you are writing a graphing program and you
are graphing the equation <emphasis>y</emphasis>= 2 <emphasis>x</emphasis> <superscript>2</superscript> + 5, and you want only those values of <emphasis>x</emphasis>
for which the <emphasis>y</emphasis> value is less than 100. You can generate all the numbers 0 through
100, which will certainly be enough, and then <literal>take-while</literal> the condition holds:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(take-while (fn [x] (&lt; (+ (* 2 x x) 5) 100))
            (range 0 100))
;; =&gt; (0 1 2 3 4 5 6)</programlisting>
</section>
</section>
<section id="collections-in-depth">
<title>Collections in depth</title>
<simpara>Now that we&#8217;re acquainted with ClojureScript&#8217;s sequence abstraction and some of the
generic sequence manipulating functions, it&#8217;s time to dive into the concrete
collection types and the operations they support.</simpara>
<section id="lists-2">
<title>Lists</title>
<simpara>In ClojureScript, lists are mostly used as a data structure for grouping symbols
together into programs. Unlike in other Lisps, many of the syntactic constructs of
ClojureScript use data structures different from the list (vectors and maps).  This
makes code less uniform, but the gains in readability are well worth the price.</simpara>
<simpara>You can think of ClojureScript lists as singly linked lists, where each node
contains a value and a pointer to the rest of the list. This makes it natural (and
fast!) to add items to the front of the list, since adding to the end would require
traversal of the entire list. The prepend operation is performed using the <literal>cons</literal>
function.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(cons 0 (cons 1 (cons 2 ())))
;; =&gt; (0 1 2)</programlisting>
<simpara>We used the literal <literal>()</literal> to represent the empty list. Since it doesn&#8217;t contain any
symbols, it is not treated as a function call. However, when using list literals
that contain elements, we need to quote them to prevent ClojureScript from
evaluating them as a function call:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(cons 0 '(1 2))
;; =&gt; (0 1 2)</programlisting>
<simpara>Since the head is the position that has constant time addition in the list
collection, the <literal>conj</literal> operation on lists naturally adds items to the front:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(conj '(1 2) 0)
;; =&gt; (0 1 2)</programlisting>
<simpara>Lists and other ClojureScript data structures can be used as stacks using the
<literal>peek</literal>, <literal>pop</literal>, and <literal>conj</literal> functions. Note that the top of the stack will be the
"place" where <literal>conj</literal> adds elements, making <literal>conj</literal> equivalent to the stack&#8217;s push
operation. In the case of lists, <literal>conj</literal> adds elements to the front of the list,
<literal>peek</literal> returns the first element of the list, and <literal>pop</literal> returns a list with all the
elements but the first one.</simpara>
<simpara>Note that the two operations that return a stack (<literal>conj</literal> and <literal>pop</literal>) don&#8217;t change the
type of the collection used for the stack.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def list-stack '(0 1 2))

(peek list-stack)
;; =&gt; 0

(pop list-stack)
;; =&gt; (1 2)

(type (pop list-stack))
;; =&gt; cljs.core/List

(conj list-stack -1)
;; =&gt; (-1 0 1 2)

(type (conj list-stack -1))
;; =&gt; cljs.core/List</programlisting>
<simpara>One thing that lists are not particularly good at is random indexed access. Since
they are stored in a single linked list-like structure in memory, random access to a
given index requires a linear traversal in order to either retrieve the requested
item or throw an index out of bounds error. Non-indexed ordered collections like
lazy sequences also suffer from this limitation.</simpara>
</section>
<section id="vectors-2">
<title>Vectors</title>
<simpara>Vectors are one of the most common data structures in ClojureScript. They are used
as a syntactic construct in many places where more traditional Lisps use lists, for
example in function argument declarations and <literal>let</literal> bindings.</simpara>
<simpara>ClojureScript vectors have enclosing brackets <literal>[]</literal> in their syntax literals. They
can be created with <literal>vector</literal> and from another collection with <literal>vec</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(vector? [0 1 2])
;; =&gt; true

(vector 0 1 2)
;; =&gt; [0 1 2]

(vec '(0 1 2))
;; =&gt; [0 1 2]</programlisting>
<simpara>Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists,
vectors grow naturally from the tail, so the <literal>conj</literal> operation appends items to the
end of a vector. Insertion on the end of a vector is effectively constant time:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(conj [0 1] 2)
;; =&gt; [0 1 2]</programlisting>
<simpara>Another thing that differentiates lists and vectors is that vectors are indexed
collections and as such support efficient random index access and non-destructive
updates. We can use the <literal>nth</literal> function to retrieve values given an index:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(nth [0 1 2] 0)
;; =&gt; 0</programlisting>
<simpara>Since vectors associate sequential numeric keys (indexes) to values, we can treat
them as an associative data structure. ClojureScript provides the <literal>assoc</literal> function
that, given an associative data structure and a set of key-value pairs, yields a new
data structure with the values corresponding to the keys modified. Indexes begin at
zero for the first element in a vector.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(assoc ["cero" "uno" "two"] 2 "dos")
;; =&gt; ["cero" "uno" "dos"]</programlisting>
<simpara>Note that we can only <literal>assoc</literal> to a key that is either contained in the vector
already or if it is the last position in a vector:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(assoc ["cero" "uno" "dos"] 3 "tres")
;; =&gt; ["cero" "uno" "dos" "tres"]

(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]</programlisting>
<simpara>Perhaps surprisingly, associative data structures can also be used as
functions. They are functions of their keys to the values they are associated
with. In the case of vectors, if the given key is not present an exception is
thrown:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(["cero" "uno" "dos"] 0)
;; =&gt; "cero"

(["cero" "uno" "dos"] 2)
;; =&gt; "dos"

(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3</programlisting>
<simpara>As with lists, vectors can also be used as stacks with the <literal>peek</literal>, <literal>pop</literal>, and <literal>conj</literal>
functions. Note, however, that vectors grow from the opposite end of the collection
as lists:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def vector-stack [0 1 2])

(peek vector-stack)
;; =&gt; 2

(pop vector-stack)
;; =&gt; [0 1]

(type (pop vector-stack))
;; =&gt; cljs.core/PersistentVector

(conj vector-stack 3)
;; =&gt; [0 1 2 3]

(type (conj vector-stack 3))
;; =&gt; cljs.core/PersistentVector</programlisting>
<simpara>The <literal>map</literal> and <literal>filter</literal> operations return lazy sequences, but as it is common to need
a fully realized sequence after performing those operations, vector-returning
counterparts of such functions are available as <literal>mapv</literal> and <literal>filterv</literal>. They have the
advantages of being faster than building a vector from a lazy sequence and making
your intent more explicit:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [0 1 2])
;; =&gt; (1 2 3)

(type (map inc [0 1 2]))
;; =&gt; cljs.core/LazySeq

(mapv inc [0 1 2])
;; =&gt; [1 2 3]

(type (mapv inc [0 1 2]))
;; =&gt; cljs.core/PersistentVector</programlisting>
</section>
<section id="maps">
<title>Maps</title>
<simpara>Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a
syntactic construct, particularly for attaching <link linkend="metadata-section">metadata</link> to
vars. Any ClojureScript data structure can be used as a key in a map, although it&#8217;s
common to use keywords since they can also be called as functions.</simpara>
<simpara>ClojureScript maps are written literally as key-value pairs enclosed in braces
<literal>{}</literal>. Alternatively, they can be created with the <literal>hash-map</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map? {:name "Cirilla"})
;; =&gt; true

(hash-map :name "Cirilla")
;; =&gt; {:name "Cirilla"}

(hash-map :name "Cirilla" :surname "Fiona")
;; =&gt; {:name "Cirilla" :surname "Fiona"}</programlisting>
<simpara>Since regular maps don&#8217;t have a specific order, the <literal>conj</literal> operation just adds one
or more key-value pairs to a map. <literal>conj</literal> for maps expects one or more sequences of
key-value pairs as its last arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ciri {:name "Cirilla"})

(conj ciri [:surname "Fiona"])
;; =&gt; {:name "Cirilla", :surname "Fiona"}

(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; =&gt; {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}</programlisting>
<simpara>In the preceding example, it just so happens that the order was preserved, but if
you have many keys, you will see that the order is not preserved.</simpara>
<simpara>Maps associate keys to values and, as such, are an associative data structure. They
support adding associations with <literal>assoc</literal> and, unlike vectors, removing them with
<literal>dissoc</literal>. <literal>assoc</literal> will also update the value of an existing key. Let&#8217;s explore these
functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(assoc {:name "Cirilla"} :surname "Fiona")
;; =&gt; {:name "Cirilla", :surname "Fiona"}
(assoc {:name "Cirilla"} :name "Alfonso")
;; =&gt; {:name "Alfonso"}
(dissoc {:name "Cirilla"} :name)
;; =&gt; {}</programlisting>
<simpara>Maps are also functions of their keys, returning the values related to the given
keys. Unlike vectors, they return <literal>nil</literal> if we supply a key that is not present in
the map:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">({:name "Cirilla"} :name)
;; =&gt; "Cirilla"

({:name "Cirilla"} :surname)
;; =&gt; nil</programlisting>
<simpara>ClojureScript also offers sorted hash maps which behave like their unsorted versions
but preserve order when iterating over them. We can create a sorted map with default
ordering with <literal>sorted-map</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def sm (sorted-map :c 2 :b 1 :a 0))
;; =&gt; {:a 0, :b 1, :c 2}

(keys sm)
;; =&gt; (:a :b :c)</programlisting>
<simpara>If we need a custom ordering we can provide a comparator function to
<literal>sorted-map-by</literal>, let&#8217;s see an example inverting the value returned by the built-in
<literal>compare</literal> function. Comparator functions take two items to compare and return -1 (if
the first item is less than the second), 0 (if they are equal), or 1 (if the first
item is greater than the second).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn reverse-compare [a b] (compare b a))

(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; =&gt; {:c 2, :b 1, :a 0}

(keys sm)
;; =&gt; (:c :b :a)</programlisting>
</section>
<section id="sets-2">
<title>Sets</title>
<simpara>Sets in ClojureScript have literal syntax as values enclosed in <literal>#{}</literal> and they can
be created with the <literal>set</literal> constructor. They are unordered collections of values
without duplicates.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(set? #{\a \e \i \o \u})
;; =&gt; true

(set [1 1 2 3])
;; =&gt; #{1 2 3}</programlisting>
<simpara>Set literals cannot contain duplicate values. If you accidentally write a set
literal with duplicates an error will be thrown:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1</programlisting>
<simpara>There are many operations that can be performed with sets, although they are located
in the <literal>clojure.set</literal> namespace and thus need to be imported. You&#8217;ll learn
<link linkend="namespace-section">the details of namespacing</link> later; for now, you only need to
know that we are loading a namespace called <literal>clojure.set</literal> and binding it to the <literal>s</literal>
symbol.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[clojure.set :as s])

(def danish-vowels #{\a \e \i \o \u \æ \ø \å})
;; =&gt; #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(def spanish-vowels #{\a \e \i \o \u})
;; =&gt; #{"a" "e" "i" "o" "u"}

(s/difference danish-vowels spanish-vowels)
;; =&gt; #{"å" "æ" "ø"}

(s/union danish-vowels spanish-vowels)
;; =&gt; #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(s/intersection danish-vowels spanish-vowels)
;; =&gt; #{"a" "e" "i" "o" "u"}</programlisting>
<simpara>A nice property of immutable sets is that they can be nested. Languages that have
mutable sets can end up containing duplicate values, but that can&#8217;t happen in
ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily
due to immutability.</simpara>
<simpara>Sets also support the generic <literal>conj</literal> operation just like every other collection does.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def spanish-vowels #{\a \e \i \o \u})
;; =&gt; #{"a" "e" "i" "o" "u"}

(def danish-vowels (conj spanish-vowels \æ \ø \å))
;; =&gt; #{"a" "e" "i" "o" "u" "æ" "ø" "å"}

(conj #{1 2 3} 1)
;; =&gt; #{1 3 2}</programlisting>
<simpara>Sets act as read-only associative data that associates the values it contains to
themselves. Since every value except <literal>nil</literal> and <literal>false</literal> is truthy in ClojureScript,
we can use sets as predicate functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def vowels #{\a \e \i \o \u})
;; =&gt; #{"a" "e" "i" "o" "u"}

(get vowels \b)
;; =&gt; nil

(contains? vowels \b)
;; =&gt; false

(vowels \a)
;; =&gt; "a"

(vowels \z)
;; =&gt; nil

(filter vowels "Hound dog")
;; =&gt; ("o" "u" "o")</programlisting>
<simpara>Sets have a sorted counterpart like maps do that are created using the functions
<literal>sorted-set</literal> and <literal>sorted-set-by</literal> which are analogous to map&#8217;s <literal>sorted-map</literal> and
<literal>sorted-map-by</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def unordered-set #{[0] [1] [2]})
;; =&gt; #{[0] [2] [1]}

(seq unordered-set)
;; =&gt; ([0] [2] [1])

(def ordered-set (sorted-set [0] [1] [2]))
;; =&gt;# {[0] [1] [2]}

(seq ordered-set)
;; =&gt; ([0] [1] [2])</programlisting>
</section>
<section id="queues">
<title>Queues</title>
<simpara>ClojureScript also provides a persistent and immutable queue. Queues are not used as
pervasively as other collection types.  They can be created using the <literal>#queue []</literal>
literal syntax, but there are no convenient constructor functions for them.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def pq #queue [1 2 3])
;; =&gt; #queue [1 2 3]</programlisting>
<simpara>Using <literal>conj</literal> to add values to a queue adds items onto the rear:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def pq #queue [1 2 3])
;; =&gt; #queue [1 2 3]

(conj pq 4 5)
;; =&gt; #queue [1 2 3 4 5]</programlisting>
<simpara>A thing to bear in mind about queues is that the stack operations don&#8217;t follow the
usual stack semantics (pushing and popping from the same end). <literal>pop</literal> takes values
from the front position, and <literal>conj</literal> pushes (appends) elements to the back.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def pq #queue [1 2 3])
;; =&gt; #queue [1 2 3]

(peek pq)
;; =&gt; 1

(pop pq)
;; =&gt; #queue [2 3]

(conj pq 4)
;; =&gt; #queue [1 2 3 4]</programlisting>
<simpara>Queues are not as frequently used as lists or vectors, but it is good to know that
they are available in ClojureScript, as they may occasionally come in handy.</simpara>
</section>
</section>
</section>
<section id="destructuring-section">
<title>Destructuring</title>
<simpara>Destructuring, as its name suggests, is a way of taking apart structured data such
as collections and focusing on individual parts of them. ClojureScript offers a
concise syntax for destructuring both indexed sequences and associative data
structures that can be used any place where bindings are declared.</simpara>
<simpara>Let&#8217;s see an example of what destructuring is useful for that will help us
understand the previous statements better. Imagine that you have a sequence but are
only interested in the first and third item. You could get a reference to them
easily with the <literal>nth</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [v [0 1 2]
      fst (nth v 0)
      thrd (nth v 2)]
  [thrd fst])
;; =&gt; [2 0]</programlisting>
<simpara>However, the previous code is overly verbose. Destructuring lets us extract values
of indexed sequences more succintly using a vector on the left-hand side of a
binding:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [[fst _ thrd] [0 1 2]]
  [thrd fst])
;; =&gt; [2 0]</programlisting>
<simpara>In the above example, <literal>[fst _ thrd]</literal> is a destructuring form. It is represented as a
vector and used for binding indexed values to the symbols <literal>fst</literal> and <literal>thrd</literal>,
corresponding to the index <literal>0</literal> and <literal>2</literal>, respectively. The <literal>_</literal> symbol is used as a
placeholder for indexes we are not interested in — in this case <literal>1</literal>.</simpara>
<simpara>Note that destructuring is not limited to the <literal>let</literal> binding form; it works in almost
every place where we bind values to symbols such as in the <literal>for</literal> and <literal>doseq</literal> special
forms or in function arguments. We can write a function that takes a pair and swaps
its positions very concisely using destructuring syntax in function arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn swap-pair [[fst snd]]
  [snd fst])

(swap-pair [1 2])
;; =&gt; [2 1]

(swap-pair '(3 4))
;; =&gt; [4 3]</programlisting>
<simpara>Positional destructuring with vectors is quite handy for taking indexed values out
of sequences, but sometimes we don&#8217;t want to discard the rest of the elements in the
sequence when destructuring.  Similarly to how <literal>&amp;</literal> is used for accepting variadic
function arguments, the ampersand can be used inside a vector destructuring form for
grouping together the rest of a sequence:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [[fst snd &amp; more] (range 10)]
  {:first fst
   :snd snd
   :rest more})
;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}</programlisting>
<simpara>Notice how the value in the <literal>0</literal> index got bound to <literal>fst</literal>, the value in the <literal>1</literal> index
got bound to <literal>snd</literal>, and the sequence of elements from <literal>2</literal> onwards got bound to the
<literal>more</literal> symbol.</simpara>
<simpara>We may still be interested in a data structure as a whole even when we are
destructuring it. This can be achieved with the <literal>:as</literal> keyword. If used inside a
destructuring form, the original data structure is bound to the symbol following
that keyword:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [[fst snd &amp; more :as original] (range 10)]
  {:first fst
   :snd snd
   :rest more
   :original original})
;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}</programlisting>
<simpara>Not only can indexed sequences be destructured, but associative data can also be
destructured. Its destructuring binding form is represented as a map instead of a
vector, where the keys are the symbols we want to bind values to and the values are
the keys that we want to look up in the associative data structure. Let&#8217;s see an
example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{language :language} {:language "ClojureScript"}]
  language)
;; =&gt; "ClojureScript"</programlisting>
<simpara>In the above example, we are extracting the value associated with the <literal>:language</literal>
key and binding it to the <literal>language</literal> symbol. When looking up keys that are not
present, the symbol will get bound to <literal>nil</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{name :name} {:language "ClojureScript"}]
  name)
;; =&gt; nil</programlisting>
<simpara>Associative destructuring lets us give default values to bindings which will be used
if the key isn&#8217;t found in the data structure we are taking apart. A map following
the <literal>:or</literal> keyword is used for default values as the following examples show:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{name :name :or {name "Anonymous"}} {:language "ClojureScript"}]
  name)
;; =&gt; "Anonymous"

(let [{name :name :or {name "Anonymous"}} {:name "Cirilla"}]
  name)
;; =&gt; "Cirilla"</programlisting>
<simpara>Associative destructuring also supports binding the original data structure to a
symbol placed after the <literal>:as</literal> keyword:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{name :name :as person} {:name "Cirilla" :age 49}]
  [name person])
;; =&gt; ["Cirilla" {:name "Cirilla" :age 49}]</programlisting>
<simpara>Keywords aren&#8217;t the only things that can be the keys of associative data structures.
Numbers, strings, symbols and many other data structures can be used as keys, so we
can destructure using those, too. Note that we need to quote the symbols to prevent
them from being resolved as a var lookup:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{one 1} {0 "zero" 1 "one"}]
  one)
;; =&gt; "one"

(let [{name "name"} {"name" "Cirilla"}]
  name)
;; =&gt; "Cirilla"

(let [{lang 'language} {'language "ClojureScript"}]
  lang)
;; =&gt; "ClojureScript"</programlisting>
<simpara>Since the values corresponding to keys are usually bound to their equivalent symbol
representation (for example, when binding the value of <literal>:language</literal> to the symbol
<literal>language</literal>) and keys are usually keywords, strings, or symbols, ClojureScript offers
shorthand syntax for these cases.</simpara>
<simpara>We&#8217;ll show examples of all of these, starting with destructuring keywords using
<literal>:keys</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{:keys [name surname]} {:name "Cirilla" :surname "Fiona"}]
  [name surname])
;; =&gt; ["Cirilla" "Fiona"]</programlisting>
<simpara>As you can see in the example, if we use the <literal>:keys</literal> keyword and associate it with a
vector of symbols in a binding form, the values corresponding to the keywordized
version of the symbols will be bound to them. The <literal>{:keys [name surname]}</literal>
destructuring is equivalent to <literal>{name :name surname :surname}</literal>, only shorter.</simpara>
<simpara>The string and symbol shorthand syntax works exactly like <literal>:keys</literal>, but using the
<literal>:strs</literal> and <literal>:syms</literal> keywords respectively:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{:strs [name surname]} {"name" "Cirilla" "surname" "Fiona"}]
  [name surname])
;; =&gt; ["Cirilla" "Fiona"]

(let [{:syms [name surname]} {'name "Cirilla" 'surname "Fiona"}]
  [name surname])
;; =&gt; ["Cirilla" "Fiona"]</programlisting>
<simpara>If the map you want to destructure has namespaced keywords as keys, you also can
do it using the keyword syntax inside <literal>:keys</literal> vector:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{:keys [::name ::surname]} {::name "Cirilla" ::surname "Fiona"}]
  [name surname])
;; =&gt; ["Cirilla" "Fiona"]</programlisting>
<simpara>An interesting property of destructuring is that we can nest destructuring forms
arbitrarily, which makes code that accesses nested data on a collection very easy to
understand, as it mimics the collection&#8217;s structure:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [{[fst snd] :languages} {:languages ["ClojureScript" "Clojure"]}]
  [snd fst])
;; =&gt; ["Clojure" "ClojureScript"]</programlisting>
</section>
<section id="threading-macros">
<title>Threading Macros</title>
<simpara>Threading macros, also known as arrow functions, enables one to write
more readable code when multiple nested function calls are performed.</simpara>
<simpara>Imagine you have <literal>(f (g (h x)))</literal> where a function <literal>f</literal> receives as its first
parameter the result of executing function <literal>g</literal>, repeated multiple times. With
the most basic <literal>&#8594;</literal> threading macro you can convert that into <literal>(-&gt; x (h) (g)
(f))</literal> which is easier to read.</simpara>
<simpara>The result is syntactic sugar, because the arrow functions are defined as macros
and it does not imply any runtime performance. The <literal>(-&gt; x (h) (g) (f))</literal> is
automatically converted to (f (g (h x))) at compile time.</simpara>
<simpara>Take note that the parenthesis on <literal>h</literal>, <literal>g</literal> and <literal>f</literal> are optional, and can be
ommited: <literal>(f (g (h x)))</literal> is the same as <literal>(-&gt; x h g f)</literal>.</simpara>
<section id="thread-first-macro">
<title><literal>-&gt;</literal> (thread-first macro)</title>
<simpara>This is called <emphasis role="strong">thread first</emphasis> because it threads the first argument throught the
different expressions as first arguments.</simpara>
<simpara>Using a more concrete example, this is how the code looks without using
threading macros:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def book {:name "Lady of the Lake"
           :readers 0})

(update (assoc book :age 1999) :readers inc)
;; =&gt; {:name "Lady of the lake" :age 1999 :readers 1}</programlisting>
<simpara>We can rewrite that code to use the <literal>-&gt;</literal> threading macro:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(-&gt; book
    (assoc :age 1999)
    (update :readers inc))
;; =&gt; {:name "Lady of the lake" :age 1999 :readers 1}</programlisting>
<simpara>This threading macro is especially useful for transforming data structures,
because <emphasis>ClojureScript</emphasis> (and <emphasis>Clojure</emphasis>) functions for data structures
transformations consistently uses the first argument for receive the data
structure.</simpara>
</section>
<section id="thread-last-macro">
<title><literal>-&gt;&gt;</literal> (thread-last macro)</title>
<simpara>The main difference between the thread-last and thread-first macros is that instead
of threading the first argument given as the first argument on the following expresions,
it threads it as the last argument.</simpara>
<simpara>Let&#8217;s look at an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def numbers [1 2 3 4 5 6 7 8 9 0])

(take 2 (filter odd? (map inc numbers)))
;; =&gt; (3 5)</programlisting>
<simpara>The same code written using <literal>-&gt;&gt;</literal> threading macro:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(-&gt;&gt; numbers
     (map inc)
     (filter odd?)
     (take 2))
;; =&gt; (3 5)</programlisting>
<simpara>This threading macro is especially useful for transforming sequences or collections
of data because <emphasis>ClojureScript</emphasis> functions that work with sequences and collections
consistently use the last argument position to receive them.</simpara>
</section>
<section id="as-thread-as-macro">
<title><literal>as-&gt;</literal> (thread-as macro)</title>
<simpara>Finally, there are cases where neither <literal>-&gt;</literal> nor <literal>-&gt;&gt;</literal> are applicable. In these
cases, you’ll need to use <literal>as-&gt;</literal>, the more flexible alternative, that allows
you to thread into any argument position, not just the first or last.</simpara>
<simpara>It expects two fixed arguments and an arbitrary number of expressions. As with
<literal>-&gt;</literal>, the first argument is a value to be threaded through the following
forms. The second argument is the name of a binding. In each of the subsequent
forms, the bound name can be used for the prior expression&#8217;s result.</simpara>
<simpara>Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(as-&gt; numbers $
  (map inc $)
  (filter odd? $)
  (first $)
  (hash-map :result $ :id 1))
;; =&gt; {:result 3 :id 1}</programlisting>
</section>
<section id="some-some-thread-some-macros">
<title><literal>some-&gt;</literal>, <literal>some-&gt;&gt;</literal> (thread-some macros)</title>
<simpara>Two of the more specialized threading macros that <emphasis>ClojureScript</emphasis> comes with. They work
in the same way as their analagous <literal>-&gt;</literal> and <literal>-&gt;&gt;</literal> macros with the additional
support for short-circuiting the expression if one of the expresions evaluates
to <literal>nil</literal>.</simpara>
<simpara>Let&#8217;s see another example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(some-&gt; (rand-nth [1 nil])
        (inc))
;; =&gt; 2

(some-&gt; (rand-nth [1 nil])
        (inc))
;; =&gt; nil</programlisting>
<simpara>This is an easy way avoid null pointer exceptions.</simpara>
</section>
<section id="cond-cond-thread-cond-macros">
<title><literal>cond-&gt;</literal>, <literal>cond-&gt;&gt;</literal> (thread-cond macros)</title>
<simpara>The <literal>cond-&gt;</literal> and <literal>cond-&gt;&gt;</literal> macros are analogous to <literal>-&gt;</literal> and <literal>-&gt;&gt;</literal> that offers
the ability to conditionally skip some steps from the pipeline. Let see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn describe-number
  [n]
  (cond-&gt; []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3)
;; =&gt; ["odd" "positive"]

(describe-number 4)
;; =&gt; ["even" "positive"]</programlisting>
<simpara>The value threading only happens when the corresponding condition evaluates to
logical true.</simpara>
</section>
<section id="additional-readings">
<title>Additional Readings</title>
<itemizedlist>
<listitem>
<simpara><ulink url="http://www.spacjer.com/blog/2015/11/09/lesser-known-clojure-variants-of-threading-macro/">http://www.spacjer.com/blog/2015/11/09/lesser-known-clojure-variants-of-threading-macro/</ulink></simpara>
</listitem>
<listitem>
<simpara><ulink url="http://clojure.org/guides/threading_macros">http://clojure.org/guides/threading_macros</ulink></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="reader-conditionals">
<title>Reader Conditionals</title>
<simpara>This language feature allows different dialects of Clojure to share common code that
is mostly platform independent but need some platform dependent code.</simpara>
<simpara>To use reader conditionals, all you need is to rename your source file with
<literal>.cljs</literal> extension to one with <literal>.cljc</literal>, because reader conditionals only work if
they are placed in files with <literal>.cljc</literal> extension.</simpara>
<section id="standard">
<title>Standard (<literal>#?</literal>)</title>
<simpara>There are two types of reader conditionals, standard and splicing. The standard
reader conditional behaves similarly to a traditional cond and the syntax looks
like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn parse-int
  [v]
  #?(:clj  (Integer/parseInt v)
     :cljs (js/parseInt v)))</programlisting>
<simpara>As you can observe, <literal>#?</literal> reading macro looks very similar to cond, the difference is
that the condition is just a keyword that identifies the platform, where <literal>:cljs</literal> is
for <emphasis>ClojureScript</emphasis> and <literal>:clj</literal> is for <emphasis>Clojure</emphasis>. The advantage of this approach, is
that it is evaluated at compile time so no runtime performance overhead exists for
using this.</simpara>
</section>
<section id="splicing">
<title>Splicing (<literal>#?@</literal>)</title>
<simpara>The splicing reader conditional works in the same way as the standard and allows
splice lists into the containing form. The <literal>#?@</literal> reader macro is used for that
and the code looks like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn make-list
  []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))

;; On ClojureScript
(make-list)
;; =&gt; (1 2 3 4)</programlisting>
<simpara>The <emphasis>ClojureScript</emphasis> compiler will read that code as this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn make-list
  []
  (list 1 2 3 4))</programlisting>
<simpara>The splicing reader conditional can&#8217;t be used to splice multiple top level forms,
so the following code is ilegal:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#?@(:cljs [(defn func-a [] :a)
           (defn func-b [] :b)])
;; =&gt; #error "Reader conditional splicing not allowed at the top level."</programlisting>
<simpara>If you need so, you can use multiple forms or just use <literal>do</literal> block for group
multiple forms together:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#?(:cljs (defn func-a [] :a))
#?(:cljs (defn func-b [] :b))

;; Or

#?(:cljs
   (do
     (defn func-a [] :a)
     (defn func-b [] :b)))</programlisting>
</section>
<section id="more-readings">
<title>More readings</title>
<itemizedlist>
<listitem>
<simpara><ulink url="http://clojure.org/guides/reader_conditionals">http://clojure.org/guides/reader_conditionals</ulink></simpara>
</listitem>
<listitem>
<simpara><ulink url="https://danielcompton.net/2015/06/10/clojure-reader-conditionals-by-example">https://danielcompton.net/2015/06/10/clojure-reader-conditionals-by-example</ulink></simpara>
</listitem>
<listitem>
<simpara><ulink url="https://github.com/funcool/cuerdas">https://github.com/funcool/cuerdas</ulink> (example small project that uses
reader conditionals)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="namespace-section">
<title>Namespaces</title>
<section id="defining-a-namespace">
<title>Defining a namespace</title>
<simpara>The <emphasis>namespace</emphasis> is ClojureScript&#8217;s fundamental unit of code modularity. Namespaces
are analogous to Java packages or Ruby and Python modules and can be defined with
the <literal>ns</literal> macro. If you have ever looked at a little bit of ClojureScript source, you
may have noticed something like this at the beginning of the file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")</programlisting>
<simpara>Namespaces are dynamic, meaning you can create one at any time. However, the
convention is to have one namespace per file. Naturally, a namespace definition is
usually at the beginning of the file, followed by an optional docstring.</simpara>
<simpara>Previously we have explained vars and symbols. Every var that you define will be
associated with its namespace. If you do not define a concrete namespace, then the
default one called "cljs.user" will be used:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x "hello")
;; =&gt; #'cljs.user/x</programlisting>
</section>
<section id="loading-other-namespaces">
<title>Loading other namespaces</title>
<simpara>Defining a namespace and the vars in it is really easy, but it&#8217;s not very useful if
we can&#8217;t use symbols from other namespaces. For this purpose, the <literal>ns</literal> macro offers
a simple way to load other namespaces.</simpara>
<simpara>Observe the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; =&gt; "HELLO"</programlisting>
<simpara>As you can observe, we are using fully qualified names (namespace + var name) for
access to vars and functions from different namespaces.</simpara>
<simpara>While this will let you access other namespaces, it&#8217;s also repetitive and overly
verbose. It will be especially uncomfortable if the name of a namespace is very
long. To solve that, you can use the <literal>:as</literal> directive to create an additional
(usually shorter) alias to the namespace.  This is how it can be done:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; =&gt; "HELLO"</programlisting>
<simpara>One peculiarity of the namespace aliases, is that they can be used to obtain
namespaced keywords from a specific namespace:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require [myapp.core :as c]))

::c/foo
;; =&gt; :myapp.core/foo</programlisting>
<simpara>In the same way, you can namespace all the keys on the moment of creation of a
map:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x #::c {:a 1})

x
;; =&gt; #:myapp.core{:a 1}

(::c/a x)
;; =&gt; 1</programlisting>
<simpara>Additionally, <emphasis>ClojureScript</emphasis> offers a simple way to refer to specific vars or
functions from a concrete namespace using the <literal>:refer</literal> directive, followed by a
sequence of symbols that will refer to vars in the namespace. Effectively, it is as
if those vars and functions are now part of your namespace, and you do not need to
qualify them at all.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require [clojure.string :refer [upper-case]]))
(upper-case x)
;; =&gt; "HELLO"</programlisting>
<simpara>And finally, you should know that everything located in the <literal>cljs.core</literal> namespace is
automatically loaded and you should not require it explicitly. Sometimes you may
want to declare vars that will clash with some others defined in the <literal>cljs.core</literal>
namespace. To do this, the <literal>ns</literal> macro offers another directive that allows you to
exclude specific symbols and prevent them from being automatically loaded.</simpara>
<simpara>Observe the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (&gt; x y)
    y
    x))</programlisting>
<simpara>The <literal>ns</literal> macro also has other directives for loading host classes (with <literal>:import</literal>)
and macros (with <literal>:refer-macros</literal>), but these are explained in other sections.</simpara>
</section>
<section id="namespaces-and-file-names">
<title>Namespaces and File Names</title>
<simpara>When you have a namespace like <literal>myapp.core</literal>, the code must be in a file named
<emphasis>core.cljs</emphasis> inside the <emphasis>myapp</emphasis> directory.  So, the preceding examples with
namespaces <literal>myapp.core</literal> and <literal>myapp.main</literal> would be found in project with a file
structure like this:</simpara>
<screen>myapp
└── src
    └── myapp
        ├── core.cljs
        └── main.cljs</screen>
</section>
</section>
<section id="abstractions-and-polymorphism">
<title>Abstractions and Polymorphism</title>
<simpara>I&#8217;m sure that at more than one time you have found yourself in this situation: you
have defined a great abstraction (using interfaces or something similar) for your
"business logic", and you have found the need to deal with another module over which
you have absolutely no control, and you probably were thinking of creating adapters,
proxies, and other approaches that imply a great amount of additional complexity.</simpara>
<simpara>Some dynamic languages allow "monkey-patching"; languages where the classes are open
and any method can be defined and redefined at any time. Also, it is well known that
this technique is a very bad practice.</simpara>
<simpara>We can not trust languages that allow you to silently overwrite methods that you are
using when you import third party libraries; you cannot expect consistent behavior
when this happens.</simpara>
<simpara>These symptoms are commonly called the "expression problem";
see <ulink url="http://en.wikipedia.org/wiki/Expression_problem">http://en.wikipedia.org/wiki/Expression_problem</ulink> for more details</simpara>
<section id="protocols">
<title>Protocols</title>
<simpara>The <emphasis>ClojureScript</emphasis> primitive for defining "interfaces" is called a protocol. A
protocol consists of a name and set of functions. All the functions have at least
one argument corresponding to the <literal>this</literal> in JavaScript or <literal>self</literal> in Python.</simpara>
<simpara>Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScript’s <literal>this</literal>, as previously mentioned).</simpara>
<simpara>A protocol looks like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.testproto)

(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string associated with this function."))</programlisting>
<note>
<simpara>the "I" prefix is commonly used to designate the separation of protocols and
types. In the Clojure community, there are many different opinions about how the "I"
prefix should be used. In our opinion, it is an acceptable solution to avoid name
clashing and possible confusion. But not using the prefix is not considered bad
practice.</simpara>
</note>
<simpara>From the user perspective, protocol functions are simply plain functions defined in
the namespace where the protocol is defined. This enables an easy and simple aproach
for avoid conflicts between different protocols implemented for the same type that
have conflicting function names.</simpara>
<simpara>Here is an example. Let&#8217;s create a protocol called <literal>IInvertible</literal> for data that can
be "inverted".  It will have a single method named <literal>invert</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol IInvertible
  "This is a protocol for data types that are 'invertible'"
  (invert [this] "Invert the given item."))</programlisting>
<section id="extending-existing-types">
<title>Extending existing types</title>
<simpara>One of the big strengths of protocols is the ability to extend existing and maybe
third party types. This operation can be done in different ways.</simpara>
<simpara>The majority of time you will tend to use the <emphasis role="strong">extend-protocol</emphasis> or the <emphasis role="strong">extend-type</emphasis>
macros. This is how <literal>extend-type</literal> syntax looks:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  ProtocolB
  (function-from-protocol-b-1 [this parameter1]
    ;; implementation here
    )
  (function-from-protocol-b-2 [this parameter1 parameter2]
    ;; implementation here
    ))</programlisting>
<simpara>You can observe that with <emphasis role="strong">extend-type</emphasis> you are extending a single type with
different protocols in a single expression.</simpara>
<simpara>Let&#8217;s play with our <literal>IInvertible</literal> protocol defined previously:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))

(extend-type cljs.core.List
  IInvertible
  (invert [this] (reverse this)))

(extend-type cljs.core.PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))</programlisting>
<simpara>You may note that a special symbol <emphasis role="strong">string</emphasis> is used instead of <literal>js/String</literal> for
extend the protol for string. This is because the builtin javascript types have
special treatment and if you replace the <literal>string</literal> with <literal>js/String</literal> the compiler
will emit a warning about that.</simpara>
<simpara>So if you want extend your protocol to javascript primitive types, instead of using
<literal>js/Number</literal>, <literal>js/String</literal>, <literal>js/Object</literal>, <literal>js/Array</literal>, <literal>js/Boolean</literal> and <literal>js/Function</literal>
you should use the respective special symbols: <literal>number</literal>, <literal>string</literal>, <literal>object</literal>,
<literal>array</literal>, <literal>boolean</literal> and <literal>function</literal>.</simpara>
<simpara>Now, it&#8217;s time to try our protocol implementation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(invert "abc")
;; =&gt; "cba"

(invert 0)
;; =&gt; 0

(invert '(1 2 3))
;; =&gt; (3 2 1)

(invert [1 2 3])
;; =&gt; [3 2 1]</programlisting>
<simpara>In comparison, <emphasis role="strong">extend-protocol</emphasis> does the inverse; given a protocol, it adds
implementations for multiple types. This is how the syntax looks:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  TypeB
  (function-from-protocol-a [this]
    ;; implementation here
    ))</programlisting>
<simpara>Thus, the previous example could have been written equally well with this way:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-protocol IInvertible
  string
  (invert [this] (apply str (reverse this)))

  cljs.core.List
  (invert [this] (reverse this))

  cljs.core.PersistentVector
  (invert [this] (into [] (reverse this))))</programlisting>
</section>
<section id="participate-in-clojurescript-abstractions">
<title>Participate in ClojureScript abstractions</title>
<simpara>ClojureScript itself is built up on abstractions defined as protocols. Almost all
behavior in the <emphasis>ClojureScript</emphasis> language itself can be adapted to third party
libraries. Let&#8217;s look at a real life example.</simpara>
<simpara>In previous sections, we have explained the different kinds of built-in
collections. For this example we will use a <emphasis role="strong">set</emphasis>. See this snippet of code:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def mynums #{1 2})

(filter mynums [1 2 4 5 1 3 4 5])
;; =&gt; (1 2 1)</programlisting>
<simpara>What happened? In this case, the <emphasis>set</emphasis> type implements the <emphasis>ClojureScript</emphasis> internal
<literal>IFn</literal> protocol that represents an abstraction for functions or anything
callable. This way it can be used like a callable predicate in filter.</simpara>
<simpara>OK, but what happens if we want to use a regular expression as a predicate function
for filtering a collection of strings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined</programlisting>
<simpara>The exception is raised because the <literal>RegExp</literal> type does not implement the <literal>IFn</literal>
protocol so it cannot behave like a callable, but that can be easily fixed:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))</programlisting>
<simpara>Let’s analyze this: we are extending the <literal>js/RegExp</literal> type so that it implements the
<literal>invoke</literal> function in the <literal>IFn</literal> protocol. To invoke a regular expression <literal>a</literal> as if it
were a function, call the <literal>re-find</literal> function with the object of the function and the
pattern.</simpara>
<simpara>Now, you will be able use the regex instances as predicates in a filter operation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; =&gt; ("foobar" "foobaz")</programlisting>
</section>
<section id="introspection-using-protocols">
<title>Introspection using Protocols</title>
<simpara><emphasis>ClojureScript</emphasis> comes with a useful function that allows runtime introspection:
<literal>satisfies?</literal>. The purpose of this function is to determine at runtime if some object
(instance of some type) satisfies the concrete protocol.</simpara>
<simpara>So, with the previous examples, if we check if a <literal>set</literal> instance satisfies an <emphasis role="strong">IFn</emphasis>
protocol, it should return <literal>true</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(satisfies? IFn #{1})
;; =&gt; true</programlisting>
</section>
</section>
<section id="multimethods">
<title>Multimethods</title>
<simpara>We have previously talked about protocols which solve a very common use case of
polymorphism: dispatch by type. But in some circumstances, the protocol approach can
be limiting. And here, <emphasis role="strong">multimethods</emphasis> come to the rescue.</simpara>
<simpara>These <emphasis role="strong">multimethods</emphasis> are not limited to type dispatch only; instead, they also offer
dispatch by types of multiple arguments and by value. They also allow ad-hoc
hierarchies to be defined. Also, like protocols, multimethods are an "Open System",
so you or any third parties can extend a multimethod for new types.</simpara>
<simpara>The basic constructions of <emphasis role="strong">multimethods</emphasis> are the <literal>defmulti</literal> and <literal>defmethod</literal>
forms. The <literal>defmulti</literal> form is used to create the multimethod with an initial
dispatch function. This is a model of what it looks like:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)</programlisting>
<simpara>The anonymous function defined within the <literal>defmulti</literal> form is a dispatch function. It
will be called in every call to the <literal>say-hello</literal> function and should return some kind
of marker object that will be used for dispatch. In our example, it returns the
contents of the <literal>:locale</literal> key of the first argument.</simpara>
<simpara>And finally, you should add implementations. That is done with the <literal>defmethod</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anónimo")))</programlisting>
<simpara>So, if you execute that function over a hash map containing the <literal>:locale</literal> and
optionally the <literal>:name</literal> key, the multimethod will first call the dispatch function to
determine the dispatch value, then it will search for an implementation for that
value. If an implementation is found, the dispatcher will execute it. Otherwise, the
dispatch will search for a default implementation (if one is specified) and execute
it.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(say-hello {:locale :es})
;; =&gt; "Hola Anónimo"

(say-hello {:locale :en :name "Ciri"})
;; =&gt; "Hello Ciri"

(say-hello {:locale :fr})
;; =&gt; "Hello Anonymous"</programlisting>
<simpara>If the default implementation is not specified, an exception will be raised
notifying you that some value does not have an implementation for that multimethod.</simpara>
</section>
<section id="hierarchies">
<title>Hierarchies</title>
<simpara>Hierarchies are <emphasis>ClojureScript</emphasis>’s way to let you build whatever relations that your
domain may require. Hierarchies are defined in term of relations between named
objects, such as symbols, keywords, or types.</simpara>
<simpara>Hierarchies can be defined globally or locally, depending on your needs. Like
multimethods, hierarchies are not limited to a single namespace. You can extend a
hierarchy from any namespace, not only from the one in which it is defined.</simpara>
<simpara>The global namespace is more limited, for good reasons. Keywords or symbols that are
not namespaced can not be used in the global hierarchy. That behavior helps prevent
unexpected situations when two or more third party libraries use the same symbol for
different semantics.</simpara>
<section id="defining-a-hierarchy">
<title>Defining a hierarchy</title>
<simpara>The hierarchy relations should be established using the <literal>derive</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(derive ::circle ::shape)
(derive ::box ::shape)</programlisting>
<simpara>We have just defined a set of relationships between namespaced keywords. In this
case the <literal>::circle</literal> is a child of <literal>::shape</literal>, and <literal>::box</literal> is also a child of
<literal>::shape</literal>.</simpara>
<tip>
<simpara>The <literal>::circle</literal> keyword syntax is a shorthand for <literal>:current.ns/circle</literal>. So if
you are executing it in a REPL, <literal>::circle</literal> will be evaluated as <literal>:cljs.user/circle</literal>.</simpara>
</tip>
</section>
<section id="hierarchies-and-introspection">
<title>Hierarchies and introspection</title>
<simpara><emphasis>ClojureScript</emphasis> comes with a little toolset of functions that allows runtime
introspection of globally or locally defined hierarchies. This toolset consists of
three functions: <literal>isa?</literal>, <literal>ancestors</literal>, and <literal>descendants</literal>.</simpara>
<simpara>Let&#8217;s see an example of how it can be used with the hierarchy defined in the
previous example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ancestors ::box)
;; =&gt; #{:cljs.user/shape}

(descendants ::shape)
;; =&gt; #{:cljs.user/circle :cljs.user/box}

(isa? ::box ::shape)
;; =&gt; true

(isa? ::rect ::shape)
;; =&gt; false</programlisting>
</section>
<section id="locally-defined-hierarchies">
<title>Locally defined hierarchies</title>
<simpara>As we mentioned previously, in <emphasis>ClojureScript</emphasis> you also can define local
hierarchies. This can be done with the <literal>make-hierarchy</literal> function. Here is an example
of how you can replicate the previous example using a local hierarchy:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def h (-&gt; (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))</programlisting>
<simpara>Now you can use the same introspection functions with that locally defined
hierarchy:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(isa? h :box :shape)
;; =&gt; true

(isa? :box :shape)
;; =&gt; false</programlisting>
<simpara>As you can observe, in local hierarchies we can use normal (not namespace qualified)
keywords, and if we execute the <literal>isa?</literal> without passing the local hierarchy
parameter, it returns <literal>false</literal> as expected.</simpara>
</section>
<section id="hierarchies-in-multimethods">
<title>Hierarchies in multimethods</title>
<simpara>One of the big advantages of hierarchies is that they work very well together with
multimethods.  This is because multimethods by default use the <literal>isa?</literal> function for
the last step of dispatching.</simpara>
<simpara>Let&#8217;s see an example to clearly understand what that means. First, we define the
multimethod with the <literal>defmulti</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy #'h)</programlisting>
<simpara>With the <literal>:hierarchy</literal> keyword parameter, we indicate to the multimethod what
hierarchy we want to use; if it is not specified, the global hierarchy will be used.</simpara>
<simpara>Second, we define an implementation for our multimethod using the <literal>defmethod</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmethod stringify-shape :box
  [_]
  "A box shape")

(defmethod stringify-shape :shape
  [_]
  "A generic shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")</programlisting>
<simpara>Now, let&#8217;s see what happens if we execute that function with a box:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(stringify-shape :box)
;; =&gt; "A box shape"</programlisting>
<simpara>Now everything works as expected; the multimethod executes the direct matching
implementation for the given parameter. Next, let&#8217;s see what happens if we execute
the same function but with the <literal>:circle</literal> keyword as the parameter which does not
have the direct matching dispatch value:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(stringify-shape :circle)
;; =&gt; "A generic shape"</programlisting>
<simpara>The multimethod automatically resolves it using the provided hierarchy, and since
<literal>:circle</literal> is a descendant of <literal>:shape</literal>, the <literal>:shape</literal> implementation is executed.</simpara>
<simpara>Finally, if you give a keyword that isn&#8217;t part of the hierarchy, you get the
<literal>:default</literal> implementation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(stringify-shape :triangle)
;; =&gt; "Unexpected object"</programlisting>
</section>
</section>
</section>
<section id="data-types">
<title>Data types</title>
<simpara>Until now, we have used maps, sets, lists, and vectors to represent our data. And in
most cases, this is a really great approach. But sometimes we need to define our own
types, and in this book we will call them <emphasis role="strong">data types</emphasis>.</simpara>
<simpara>A data type provides the following:</simpara>
<itemizedlist>
<listitem>
<simpara>A unique host-backed type, either named or anonymous.</simpara>
</listitem>
<listitem>
<simpara>The ability to implement protocols (inline).</simpara>
</listitem>
<listitem>
<simpara>Explicitly declared structure using fields or closures.</simpara>
</listitem>
<listitem>
<simpara>Map-like behavior (via records, see below).</simpara>
</listitem>
</itemizedlist>
<section id="deftype">
<title>Deftype</title>
<simpara>The most low-level construction in <emphasis>ClojureScript</emphasis> for creating your own types is
the <literal>deftype</literal> macro. As a demonstration, we will define a type called <literal>User</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype User [firstname lastname])</programlisting>
<simpara>Once the type has been defined, we can create an instance of our <literal>User</literal>. In the
following example, the <literal>.</literal> after <literal>User</literal> indicates that we are calling a constructor.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def person (User. "Triss" "Merigold"))</programlisting>
<simpara>Its fields can be accessed using the prefix dot notation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-firstname person)
;; =&gt; "Triss"</programlisting>
<simpara>Types defined with <literal>deftype</literal> (and <literal>defrecord</literal>, which we will see later) create a
host-backed class-like object associated with the current namespace. For
convenience, <emphasis>ClojureScript</emphasis> also defines a constructor function called <literal>&#8594;User</literal>
that can be imported using the <literal>:require</literal> directive.</simpara>
<simpara>We personally do not like this type of function, and we prefer to define our own
constructors with more idiomatic names:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn make-user
  [firstname lastname]
  (User. firstname lastname))</programlisting>
<simpara>We use this in our code instead of <literal>&#8594;User</literal>.</simpara>
</section>
<section id="defrecord">
<title>Defrecord</title>
<simpara>The record is a slightly higher-level abstraction for defining types in
<emphasis>ClojureScript</emphasis> and should be the preferred way to do it.</simpara>
<simpara>As we know, <emphasis>ClojureScript</emphasis> tends to use plain data types such as maps, but in most
cases we need a named type to represent the entities of our application. Here come
the records.</simpara>
<simpara>A record is a data type that implements the map protocol and therefore can be used
like any other map.  And since records are also proper types, they support
type-based polymorphism through protocols.</simpara>
<simpara>In summary: with records, we have the best of both worlds, maps that can play in
different abstractions.</simpara>
<simpara>Let&#8217;s start defining the <literal>User</literal> type but using records:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord User [firstname lastname])</programlisting>
<simpara>It looks really similar to the <literal>deftype</literal> syntax; in fact, it uses <literal>deftype</literal> behind
the scenes as a low-level primitive for defining types.</simpara>
<simpara>Now, look at the difference with raw types for access to its fields:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def person (User. "Yennefer" "of Vengerberg"))

(:firstname person)
;; =&gt; "Yennefer"

(get person :firstname)
;; =&gt; "Yennefer"</programlisting>
<simpara>As we mentioned previously, records are maps and act like them:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map? person)
;; =&gt; true</programlisting>
<simpara>And like maps, they support extra fields that are not initially defined:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def person2 (assoc person :age 92))

(:age person2)
;; =&gt; 92</programlisting>
<simpara>As we can see, the <literal>assoc</literal> function works as expected and returns a new instance of
the same type but with new key value pair. But take care with <literal>dissoc</literal>! Its behavior
with records is slightly different than with maps; it will return a new record if
the field being dissociated is an optional field, but it will return a plain map if
you dissociate a mandatory field.</simpara>
<simpara>Another difference with maps is that records do not act like functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})

(plain-person :firstname)
;; =&gt; "Yennefer"

(person :firstname)
;; =&gt; person.User does not implement IFn protocol.</programlisting>
<simpara>For convenience, the <literal>defrecord</literal> macro, like <literal>deftype</literal>, exposes a <literal>&#8594;User</literal> function,
as well as an additional <literal>map&#8594;User</literal> constructor function. We have the same opinion
about that constructor as with <literal>deftype</literal> defined ones: we recommend defining your
own instead of using the other ones. But as they exist, let’s see how they can be
used:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def cirilla (-&gt;User "Cirilla" "Fiona"))
(def yen (map-&gt;User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))</programlisting>
</section>
<section id="implementing-protocols">
<title>Implementing protocols</title>
<simpara>Both type definition primitives that we have seen so far allow inline
implementations for protocols (explained in a previous section). Let&#8217;s define one
for example purposes:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))</programlisting>
<simpara>Now, you can define a type with inline implementation for an abstraction, in our
case the <literal>IUser</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; =&gt; "Yennefer of Vengerberg"</programlisting>
</section>
<section id="reify">
<title>Reify</title>
<simpara>The <literal>reify</literal> macro is an <emphasis>ad hoc constructor</emphasis> you can use to create objects without
pre-defining a type.  Protocol implementations are supplied the same as <literal>deftype</literal>
and <literal>defrecord</literal>, but in contrast, <literal>reify</literal> does not have accessible fields.</simpara>
<simpara>This is how we can emulate an instance of the user type that plays well with the
<literal>IUser</literal> abstraction:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name yen)
;; =&gt; "Yennefer of Vengerberg"</programlisting>
</section>
<section id="specify">
<title>Specify</title>
<simpara><literal>specify!</literal> is an advanced alternative to <literal>reify</literal>, allowing you to add protocol
implementations to an existing JavaScript object.  This can be useful if you want to
graft protocols onto a JavaScript library&#8217;s components.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def obj #js {})

(specify! obj
  IUser
  (full-name [_]
    "my full name"))

(full-name obj)
;; =&gt; "my full name"</programlisting>
<simpara><literal>specify</literal> is an immutable version of <literal>specify!</literal> that can be used on immutable,
copyable values implementing <literal>ICloneable</literal> (e.g. ClojureScript collections).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def a {})

(def b (specify a
         IUser
         (full-name [_]
           "my full name")))

(full-name a)
;; Error: No protocol method IUser.full-name defined for type cljs.core/PersistentArrayMap: {}

(full-name b)
;; =&gt; "my full name"</programlisting>
</section>
</section>
<section id="host-interoperability">
<title>Host interoperability</title>
<simpara><emphasis>ClojureScript</emphasis>, in the same way as its brother Clojure, is designed to be a "guest"
language. This means that the design of the language works well on top of an
existing ecosystem such as JavaScript for <emphasis>ClojureScript</emphasis> and the JVM for <emphasis>Clojure</emphasis>.</simpara>
<section id="the-types">
<title>The types</title>
<simpara><emphasis>ClojureScript</emphasis>, unlike what you might expect, tries to take advantage of every type
that the platform provides. This is a (perhaps incomplete) list of things that
<emphasis>ClojureScript</emphasis> inherits and reuses from the underlying platform:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> strings are JavaScript <emphasis role="strong">Strings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> numbers are JavaScript <emphasis role="strong">Numbers</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> <literal>nil</literal> is a JavaScript <emphasis role="strong">null</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> regular expressions are JavaScript <literal>RegExp</literal> instances.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> is not interpreted; it is always compiled down to JavaScript.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> allows easy call to platform APIs with the same semantics.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> data types internally compile to objects in JavaScript.</simpara>
</listitem>
</itemizedlist>
<simpara>On top of it, <emphasis>ClojureScript</emphasis> builds its own abstractions and types that do not
exist in the platform, such as Vectors, Maps, Sets, and others that are explained in
preceding sections of this chapter.</simpara>
</section>
<section id="interacting-with-platform-types">
<title>Interacting with platform types</title>
<simpara><emphasis>ClojureScript</emphasis> comes with a little set of special forms that allows it to interact
with platform types such as calling object methods, creating new instances, and
accessing object properties.</simpara>
<section id="access-to-the-platform">
<title>Access to the platform</title>
<simpara><emphasis>ClojureScript</emphasis> has a special syntax for access to the entire platform environment
through the <literal>js/</literal> special namespace. This is an example of an expression to execute
JavaScript&#8217;s built-in <literal>parseInt</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js/parseInt "222")
;; =&gt; 222</programlisting>
</section>
<section id="creating-new-instances">
<title>Creating new instances</title>
<simpara><emphasis>ClojureScript</emphasis> has two ways to create instances:</simpara>
<simpara>Using the <literal>new</literal> special form</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(new js/RegExp "^foo$")</programlisting>
<simpara>Using the <literal>.</literal> special form</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js/RegExp. "^foo$")</programlisting>
<simpara>The last one is the recommended way to create instances. We are not aware of any
real differences between the two forms, but in the ClojureScript community, the last
one is used most often.</simpara>
</section>
<section id="invoke-instance-methods">
<title>Invoke instance methods</title>
<simpara>To invoke methods of some object instance, as opposed to how it is done in
JavaScript (e.g., <literal>obj.method()</literal>, the method name comes first like any other
standard function in Lisp languages but with a little variation: the function name
starts with special form <literal>.</literal>.</simpara>
<simpara>Let&#8217;s see how we can call the <literal>.test()</literal> method of a regexp instance:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def re (js/RegExp "^Clojure"))

(.test re "ClojureScript")
;; =&gt; true</programlisting>
<simpara>You can invoke instance methods on JavaScript objects. The first example follows the
pattern you have seen; the last one is a shortcut:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.sqrt js/Math 2)
;; =&gt; 1.4142135623730951
(js/Math.sqrt 2)
;; =&gt; 1.4142135623730951</programlisting>
</section>
<section id="access-to-object-properties">
<title>Access to object properties</title>
<simpara>Access to an object&#8217;s properties is really very similar to calling a method. The
difference is that instead of using the <literal>.</literal> you use <literal>.-</literal>. Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-multiline re)
;; =&gt; false
(.-PI js/Math)
;; =&gt; 3.141592653589793</programlisting>
</section>
<section id="property-access-shorthand">
<title>Property access shorthand</title>
<simpara>Symbols with the <literal>js/</literal> prefix can contain dots to denote nested property access.
Both of the following expressions invoke the same function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.log js/console "Hello World")

(js/console.log "Hello World")</programlisting>
<simpara>And both of the following expressions access the same property:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-PI js/Math)
;; =&gt; 3.141592653589793

js/Math.PI
;; =&gt; 3.141592653589793</programlisting>
</section>
<section id="javascript-objects">
<title>JavaScript objects</title>
<simpara><emphasis>ClojureScript</emphasis> has different ways to create plain JavaScript objects; each one has
its own purpose. The basic one is the <literal>js-obj</literal> function. It accepts a variable
number of pairs of keys and values and returns a JavaScript object:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js-obj "country" "FR")
;; =&gt; #js {:country "FR"}</programlisting>
<simpara>The return value can be passed to some kind of third party library that accepts a
plain JavaScript object, but you can observe the real representation of the return
value of this function. It is really another form for doing the same thing.</simpara>
<simpara>Using the reader macro <literal>#js</literal> consists of prepending it to a ClojureScript map or
vector, and the result will be transformed to plain JavaScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def myobj #js {:country "FR"})</programlisting>
<simpara>The translation of that to plain JavaScript is similar to this:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var myobj = {country: "FR"};</programlisting>
<simpara>As explained in the previous section, you can also access the plain object
properties using the <literal>.-</literal> syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-country myobj)
;; =&gt; "FR"</programlisting>
<simpara>And as JavaScript objects are mutable, you can set a new value for some property
using the <literal>set!</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(set! (.-country myobj) "KR")</programlisting>
</section>
<section id="conversions">
<title>Conversions</title>
<simpara>The inconvenience of the previously explained forms is that they do not make
recursive transformations, so if you have nested objects, the nested objects will
not be converted.  Consider this example that uses Clojurescript maps, then a
similar one with JavaScript objects:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def clj-map {:country {:code "FR" :name "France"}})
;; =&gt; {:country {:code "FR", :name "France"}}
(:code (:country clj-map))
;; =&gt; "FR"

(def js-obj #js {:country {:code "FR" :name "France"}})
;; =&gt; #js {:country {:code "FR", :name "France"}
(.-country js-obj)
;; =&gt; {:code "FR", :name "France"}
(.-code (.-country js-obj)
;; =&gt; nil</programlisting>
<simpara>To solve that use case, <emphasis>ClojureScript</emphasis> comes with the <literal>clj&#8594;js</literal> and <literal>js&#8594;clj</literal>
functions that transform Clojure collection types into JavaScript and back. Note
that the conversion to ClojureScript changes the <literal>:country</literal> keyword to a string.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(clj-&gt;js {:foo {:bar "baz"}})
;; =&gt; #js {:foo #js {:bar "baz"}}
(js-&gt;clj #js {:country {:code "FR" :name "France"}}))
;; =&gt; {"country" {:code "FR", :name "France"}}</programlisting>
<simpara>In the case of arrays, there is a specialized function <literal>into-array</literal> that behaves as
expected:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(into-array ["France" "Korea" "Peru"])
;; =&gt; #js ["France" "Korea" "Peru"]</programlisting>
</section>
<section id="arrays">
<title>Arrays</title>
<simpara>In the previous example, we saw how we can create an array from an existing
<emphasis>ClojureScript</emphasis> collection. But there is another function for creating arrays:
<literal>make-array</literal>.</simpara>
<formalpara>
<title>Creating a preallocated array with length 10</title>
<para>
<programlisting language="clojure" linenumbering="unnumbered">(def a (make-array 10))
;; =&gt; #js [nil nil nil nil nil nil nil nil nil nil]</programlisting>
</para>
</formalpara>
<simpara>In <emphasis>ClojureScript</emphasis>, arrays also play well with sequence abstractions, so you can
iterate over them or simply get the number of elements with the <literal>count</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(count a)
;; =&gt; 10</programlisting>
<simpara>As arrays in the JavaScript platform are a mutable collection type, you can access a
concrete index and set the value at that position:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(aset a 0 2)
;; =&gt; 2
a
;; =&gt; #js [2 nil nil nil nil nil nil nil nil nil]</programlisting>
<simpara>Or access in an indexed way to get its values:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(aget a 0)
;; =&gt; 2</programlisting>
<simpara>In JavaScript, array index access is equivalent to object property access, so you
can use the same functions for interacting with plain objects:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def b #js {:hour 16})
;; =&gt; #js {:hour 16}

(aget b "hour")
;; =&gt; 16

(aset b "minute" 22)
;; =&gt; 22

b
;; =&gt; #js {:hour 16, :minute 22}</programlisting>
</section>
</section>
</section>
<section id="state-management">
<title>State management</title>
<simpara>We&#8217;ve learned that one of ClojureScript&#8217;s fundamental ideas is immutability. Both
scalar values and collections are immutable in ClojureScript, except those mutable
types present in the JS host like <literal>Date</literal>.</simpara>
<simpara>Immutability has many great properties but we are sometimes faced with the need to
model values that change over time. How can we achieve this if we can&#8217;t change data
structures in place?</simpara>
<section id="vars-2">
<title>Vars</title>
<simpara>Vars can be redefined at will inside a namespace but there is no way to know <emphasis role="strong">when</emphasis>
they change. The inability to redefine vars from other namespaces is a bit limiting;
also, if we are modifying state, we&#8217;re probably interested in knowing when it
occurs.</simpara>
</section>
<section id="atoms">
<title>Atoms</title>
<simpara>ClojureScript gives us the <literal>Atom</literal> type, which is an object containing a value that
can be altered at will. Besides altering its value, it also supports observation
through watcher functions that can be attached and detached from it and validation
for ensuring that the value contained in the atom is always valid.</simpara>
<simpara>If we were to model an identity corresponding to a person called Ciri, we could wrap
an immutable value containing Ciri&#8217;s data in an atom. Note that we can get the
atom&#8217;s value with the <literal>deref</literal> function or using its shorthand <literal>@</literal> notation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ciri (atom {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #&lt;Atom: {:name "Cirilla", :lastname "Fiona", :age 20}&gt;

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 20}</programlisting>
<simpara>We can use the <literal>swap!</literal> function on an atom to alter its value with a function. Since
Ciri&#8217;s birthday is today, let&#8217;s increment her age count:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(swap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 21}</programlisting>
<simpara>The <literal>reset!</literal> functions replaces the value contained in the atom with a new one:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 22}</programlisting>
<section id="observation">
<title>Observation</title>
<simpara>We can add and remove watcher functions for atoms. Whenever the atom&#8217;s value is
changed through a <literal>swap!</literal> or <literal>reset!</literal>, all the atom&#8217;s watcher functions will be
called. Watchers are added with the <literal>add-watch</literal> function. Notice that each watcher
has a key associated (<literal>:logger</literal> in the example) to it which is later used to remove
the watch from the atom.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def a (atom))

(add-watch a :logger (fn [key the-atom old-value new-value]
                       (println "Key:" key "Old:" old-value "New:" new-value)))

(reset! a 42)
;; Key: :logger Old: nil New: 42
;; =&gt; 42

(swap! a inc)
;; Key: :logger Old: 42 New: 43
;; =&gt; 43

(remove-watch a :logger)</programlisting>
</section>
</section>
<section id="volatiles">
<title>Volatiles</title>
<simpara>Volatiles, like atoms, are objects containing a value that can be altered. However,
they don&#8217;t provide the observation and validation capabilities that atoms
provide. This makes them slightly more performant and a more suitable mutable
container to use inside stateful functions that don&#8217;t need observation nor
validation.</simpara>
<simpara>Their API closely resembles that of atoms. They can be dereferenced to grab the
value they contain and support swapping and resetting with <literal>vswap!</literal> and <literal>vreset!</literal>
respectively:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ciri (volatile! {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #&lt;Volatile: {:name "Cirilla", :lastname "Fiona", :age 20}&gt;

(volatile? ciri)
;; =&gt; true

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

(vswap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

(vreset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}</programlisting>
<simpara>Note that another difference with atoms is that the constructor of volatiles uses a
bang at the end. You create volatiles with <literal>volatile!</literal> and atoms with <literal>atom</literal>.</simpara>
</section>
</section>
</chapter>
<chapter id="tooling-compiler">
<title>Tooling &amp; Compiler</title>
<simpara>This chapter will cover a little introduction to existing tooling for making
things easy when developing using ClojureScript. Unlike the previous chapter,
this chapter intends to tell different stories each independent of the other.</simpara>
<section id="getting-started-with-the-compiler">
<title>Getting Started with the Compiler</title>
<simpara>At this point, you are surely very bored with the constant theoretical explanations
about the language itself and will want to write and execute some code. The goal of
this section is to provide a little practical introduction to the <emphasis>ClojureScript</emphasis>
compiler.</simpara>
<simpara>The <emphasis>ClojureScript</emphasis> compiler takes the source code that has been split over numerous
directories and namespaces and compiles it down to JavaScript. Today, JavaScript has
a great number of different environments where it can be executed - each with its own
peculiarities.</simpara>
<simpara>This chapter intends to explain how to use <emphasis>ClojureScript</emphasis> without any additional
tooling. This will help you understand how the compiler works and how you can use it
when other tooling is not available (such as <ulink url="http://leiningen.org/">leiningen</ulink><?asciidoc-br?>
<ulink url="https://github.com/emezeske/lein-cljsbuild">cljsbuild</ulink> or
<ulink url="http://boot-clj.com/">boot</ulink>).</simpara>
<section id="execution-environments">
<title>Execution environments</title>
<simpara>What is an execution environment? An execution environment is an engine where
JavaScript can be executed. For example, the most popular execution environment is a
browser (Chrome, Firefox, &#8230;&#8203;) followed by the second most popular -
<ulink url="https://nodejs.org/">nodejs</ulink>.</simpara>
<simpara>There are others, such as Rhino (JDK 6+), Nashorn (JDK 8+), QtQuick (QT),&#8230;&#8203; but
none of them have significant differences from the first two. So,
<emphasis>ClojureScript</emphasis> at the moment may compile code to run in the browser or in
nodejs-like environments out of the box.</simpara>
</section>
<section id="download-the-compiler">
<title>Download the compiler</title>
<simpara>The fastest way to obtain all the tooling needed for ClojureScript compilaition is
installing the Clojure CLI Tools:</simpara>
<programlisting language="bash" linenumbering="unnumbered">curl -O https://download.clojure.org/install/linux-install-1.10.1.462.sh
chmod +x linux-install-1.10.1.462.sh
sudo ./linux-install-1.10.1.462.sh</programlisting>
<simpara>If you are using other operating system other than linux, refer to
<ulink url="https://clojure.org/guides/getting_started">https://clojure.org/guides/getting_started</ulink> page.</simpara>
<simpara>Although the <emphasis>ClojureScript</emphasis> is self hosted, in this book we will use
the JVM implementation, with in turn requires JDK8 or JDK11
installed. You can obtain it using your distribution default package
manager or download it from
<ulink url="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">Oracle</ulink>
or <ulink url="https://www.azul.com/downloads/zulu-community/">Azul</ulink></simpara>
<formalpara>
<title>Example installing it using a apt in a debian-like distribution</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">sudo apt-get install openjdk-8-jdk rlwrap</programlisting>
</para>
</formalpara>
</section>
<section id="compile-for-node-js">
<title>Compile for Node.js</title>
<simpara>Let’s start with a practical example compiling code that will target <emphasis role="strong">Node.js</emphasis>
(hereafter simply "nodejs"). For this example, you should have nodejs installed.</simpara>
<simpara>There are different ways to install nodejs, but the recommended way is using nvm
("Node.js Version Manager"). You can read the instructions on how to install and use
nvm on its <ulink url="https://github.com/creationix/nvm">home page</ulink>.</simpara>
<simpara>When you have installed nvm, follow installing the latest version of nodejs:</simpara>
<programlisting language="shell" linenumbering="unnumbered">nvm install v10.16.0
nvm alias default v10.16.0</programlisting>
<simpara>You can test if <emphasis role="strong">nodejs</emphasis> is installed in your system with this command:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ node --version
v10.16.0</programlisting>
<section id="create-the-example-application">
<title>Create the example application</title>
<simpara>For the first step of our practical example, we will create our application directory
structure and populate it with example code.</simpara>
<simpara>Start by creating the directory tree structure for our “hello world” application:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs</programlisting>
<simpara>Resulting in this directory tree:</simpara>
<programlisting language="text" linenumbering="unnumbered">myapp
└── src
    └── myapp
        └── core.cljs</programlisting>
<simpara>Second, write the example code into the previously created
<literal>myapp/src/myapp/core.cljs</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main
  [&amp; args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)</programlisting>
<note>
<simpara>It is very important that the declared namespace in the file exactly matches
the directory structure. This is the way <emphasis>ClojureScript</emphasis> structures its source code.</simpara>
</note>
<simpara>And finally, lets create the <literal>myapp/deps.edn</literal> declaring the clojure
and clojurescript versions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}</programlisting>
</section>
<section id="compile-the-example-application">
<title>Compile the example application</title>
<simpara>In order to compile that source code, we need a simple build script that tells the
<emphasis>ClojureScript</emphasis> compiler the source directory and the output file. <emphasis>ClojureScript</emphasis>
has a lot of other options, but at this moment we can ignore that.</simpara>
<simpara>Let’s create the <literal>myapp/build.clj</literal> file with the following content:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.build.api :as b])

(b/build "src" {:main 'myapp.core
                :output-to "main.js"
                :output-dir "out"
                :target :nodejs
                :verbose true})</programlisting>
<simpara>This is a brief explanation of the compiler options used in this example:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>:output-to</literal> parameter indicates to the compiler the destination of the compiled
code, in this case to the "main.js" file.</simpara>
</listitem>
<listitem>
<simpara>The <literal>:main</literal> property indicates to the compiler the namespace that will act as the entry
point of your application when it&#8217;s executed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>:target</literal> property indicates the platform where you want to execute the compiled
code. In this case, we are going to use <emphasis role="strong">nodejs</emphasis>. If you omit this
parameter, the source will be compiled to run in the browser environment.</simpara>
</listitem>
</itemizedlist>
<simpara>To run the compilation, just execute the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd myapp
clojure build.clj</programlisting>
<simpara>And when it finishes, execute the compiled file using <emphasis role="strong">node</emphasis>:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ node main.js
Hello world!</programlisting>
</section>
</section>
<section id="compile-for-the-browser">
<title>Compile for the Browser</title>
<simpara>In this section we are going to create an application similar to the "hello world"
example from the previous section to run in the browser environment. The minimal
requirement for this application is just a browser that can execute JavaScript.</simpara>
<simpara>The process is almost the same, and the directory structure is the same. The only
things that changes is the entry point of the application and the build script. So,
start re-creating the directory tree from previous example in a different directory.</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs</programlisting>
<simpara>Resulting in this directory tree:</simpara>
<programlisting language="text" linenumbering="unnumbered">mywebapp
└── src
    └── mywebapp
        └── core.cljs</programlisting>
<simpara>Then, write new content to the <literal>mywebapp/src/mywebapp/core.cljs</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns mywebapp.core)

(enable-console-print!)

(println "Hello world!")</programlisting>
<simpara>In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.</simpara>
<section id="compile-the-example-application-2">
<title>Compile the example application</title>
<simpara>In order to compile the source code to run properly in a browser, overwrite the
<literal>mywebapp/build.clj</literal> file with the following content:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.build.api :as b])

(b/build "src" {:output-to "main.js"
                :source-map true
                :output-dir "out/"
                :main 'mywebapp.core
                :verbose true
                :optimizations :none})</programlisting>
<simpara>This is a brief explanation of the compiler options we&#8217;re using:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>:output-to</literal> parameter indicates to the compiler the destination of the
compiled code, in this case the "main.js" file.</simpara>
</listitem>
<listitem>
<simpara>The <literal>:main</literal> property indicates to the compiler the namespace that will act as
the  entry point of your application when it&#8217;s executed.</simpara>
</listitem>
<listitem>
<simpara><literal>:source-map</literal> indicates the destination of the source map. (The source map
connects the ClojureScript source to the generated JavaScript so that error
messages can point you back to the original source.)</simpara>
</listitem>
<listitem>
<simpara><literal>:output-dir</literal> indicates the destination directory for all file sources used in a
compilation. It is just for making source maps work properly with the rest of the
code, not only your source.</simpara>
</listitem>
<listitem>
<simpara><literal>:optimizations</literal> indicates the compilation optimization. There are different
values for this option, but that will be covered in subsequent sections in
more detail.</simpara>
</listitem>
</itemizedlist>
<simpara>To run the compilation, just execute the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd mywebapp;
clojure build.clj</programlisting>
<simpara>This process can take some time, so do not worry; wait a little bit. The JVM
bootstrap with the Clojure compiler is slightly slow. In the following sections, we
will explain how to start a watch process to avoid constantly starting and stopping
this slow process.</simpara>
<simpara>While waiting for the compilation, let&#8217;s create a dummy HTML file to make it easy to
execute our example app in the browser. Create the <emphasis>index.html</emphasis> file with the
following content; it goes in the main <emphasis>mywebapp</emphasis> directory.</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>
<simpara>Now, when the compilation finishes and you have the basic HTML file you can just open
it with your favorite browser and take a look in the development tools console. The
"Hello world!" message should appear there.</simpara>
</section>
</section>
<section id="watch-process">
<title>Watch process</title>
<simpara>You may have already noticed the slow startup time of the <emphasis>ClojureScript</emphasis>
compiler. To solve this, the <emphasis>ClojureScript</emphasis> standalone compiler comes with a
tool to watch for changes in your source code, and re-compile modified files as
soon as they are written to disk.</simpara>
<simpara>Let&#8217;s start converting our build.clj script to something that can accept
arguments and execute different tasks. Let&#8217;s create a <literal>tools.clj</literal> script file
with the following content:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.build.api :as b])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-&gt; task methods (dissoc :default) keys sort)
        interposed (-&gt;&gt; all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "main.js"
   :source-map true
   :output-dir "out/"
   :main 'mywebapp.core
   :verbose true
   :optimizations :none})

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch"src" build-opts))

(task *command-line-args*)</programlisting>
<simpara>Now you can start the watch process with the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">clojure tools.clj watch</programlisting>
<simpara>Go back to the <literal>mywebapp.core</literal> namespace, and change the print text to <literal>"Hello World,
Again!"</literal>.  You&#8217;ll see that the file <literal>src/mywebapp/core.cljs</literal> the file is immediately
recompiled, and if you reload <literal>index.html</literal> in your browser the new text is displayed
in the developer console.</simpara>
<simpara>You also can start the simple build with:</simpara>
<programlisting language="bash" linenumbering="unnumbered">clojure tools.clj build</programlisting>
<simpara>And finally, if you execute the <literal>build.clj</literal> script with no params, a help message
with available "tasks" will be printed:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clojure tools.clj
Unknown or missing task. Choose one of: build, watch</programlisting>
</section>
<section id="optimization-levels">
<title>Optimization levels</title>
<simpara>The <emphasis>ClojureScript</emphasis> compiler has different levels of optimization. Behind the scenes,
those compilation levels are coming from the Google Closure Compiler.</simpara>
<simpara>A simplified overview of the compilation process is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The reader reads the code and does some analysis. This compiler may raise some
warnings during this phase.</simpara>
</listitem>
<listitem>
<simpara>Then, the <emphasis>ClojureScript</emphasis> compiler emits JavaScript code. The result is one
JavaScript output file for each ClojureScript input file.</simpara>
</listitem>
<listitem>
<simpara>The generated JavaScript files are passed through the Google Closure Compiler
which, depending on the optimization level and other options (sourcemaps, output
dir output to, &#8230;&#8203;), generates the final output file(s).</simpara>
</listitem>
</orderedlist>
<simpara>The final output format depends on the optimization level chosen:</simpara>
<section id="none">
<title>none</title>
<simpara>This optimization level causes the generated JavaScript to be written into separate
output files for each namespace, without any additional transformations to the code.</simpara>
</section>
<section id="whitespace">
<title>whitespace</title>
<simpara>This optimization level causes the generated JavaScript files to be concatenated into
a single output file, in dependency order.  Line breaks and other whitespace are
removed.</simpara>
<simpara>This reduces compilation speed somewhat, resulting in a slower compilations. However,
it is not terribly slow and it is quite usable for small-to-medium sized
applications.</simpara>
</section>
<section id="simple">
<title>simple</title>
<simpara>The simple compilation level builds on the work from the <literal>whitespace</literal> optimization
level, and additionally performs optimizations within expressions and functions, such
as renaming local variables and function parameters to have shorter names.</simpara>
<simpara>Compilation with the <literal>:simple</literal> optimization always preserves the functionality of
syntactically valid JavaScript, so it does not interfere with the interaction between
the compiled <emphasis>ClojureScript</emphasis> and other JavaScript.</simpara>
</section>
<section id="advanced">
<title>advanced</title>
<simpara>The advanced compilation level builds on the <literal>simple</literal> optimization level, and
additionally performs more aggressive optimizations and dead code elimination. This
results in a significantly smaller output file.</simpara>
<simpara>The <literal>:advanced</literal> optimizations only work for a strict subset of JavaScript which
follows the Google Closure Compiler rules.  <emphasis>ClojureScript</emphasis> generates valid
JavaScript within this strict subset, but if you are interacting with third party
JavaScript code, some additional work is required to make everything work as
expected.</simpara>
<simpara>This interaction with third party javascript libraries will be explained in later
sections.</simpara>
</section>
</section>
</section>
<section id="working-with-the-repl">
<title>Working with the REPL</title>
<section id="introduction-2">
<title>Introduction</title>
<simpara>Although you can create a source file and compile it every time you want to try
something out in ClojureScript, it&#8217;s easier to use the REPL. REPL stands for:</simpara>
<itemizedlist>
<listitem>
<simpara>Read - get input from the keyboard</simpara>
</listitem>
<listitem>
<simpara>Evaluate the input</simpara>
</listitem>
<listitem>
<simpara>Print the result</simpara>
</listitem>
<listitem>
<simpara>Loop back for more input</simpara>
</listitem>
</itemizedlist>
<simpara>In other words, the REPL lets you try out ClojureScript concepts and get immediate
feedback.</simpara>
<simpara><emphasis>ClojureScript</emphasis> comes with support for executing the REPL in different execution
environments, each of which has its own advantages and disadvantages. For example,
you can run a REPL in nodejs but in that environment you don&#8217;t have any access to the
DOM.  Which REPL environment is best for you depends on your specific needs and
requirements.</simpara>
</section>
<section id="nashorn-repl">
<title>Nashorn REPL</title>
<simpara>The Nashorn REPL is the easiest and perhaps most painless REPL environment because it
does not require any special stuff.</simpara>
<simpara>Let’s start creating a new script file for our repl playground called
<literal>tools.clj</literal> in a new directory (in our case <literal>repl_playground/tools.clj</literal>):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.repl :as repl])
(require '[cljs.repl.nashorn :as nashorn])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-&gt; task methods (dissoc :default) keys sort)
        interposed (-&gt;&gt; all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(defmethod task "repl:nashorn"
  [args]
  (repl/repl (nashorn/repl-env)
             :output-dir "out/nashorn"
             :cache-analysis true))

(task *command-line-args*)</programlisting>
<simpara>Create the <literal>repl_playground/deps.edn</literal> file with the following content (identical
from previous examples):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}</programlisting>
<simpara>And now, we can execute the REPL:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clj tools.clj repl:nashorn
ClojureScript 1.10.520
cljs.user=&gt; (prn "Hello world")
"Hello world"
nil</programlisting>
<simpara>You may have noticed that in this example we have used <literal>clj</literal> command instead of
<literal>clojure</literal>. That two commands are practically identical, the main difference is
that <literal>clj</literal> executes <literal>clojure</literal> command wrapped in <literal>rlwrap</literal>. The <literal>rlwrap</literal> tool
gives the "readline" capabilities which enables history, code navigation, and
other shell-like features that will make your REPL experience much more
pleasant.</simpara>
<simpara>If you don&#8217;t have installed it previously, you can install it with <literal>sudo apt
install -y rlwrap</literal>.</simpara>
<note>
<simpara>This is a basic repl, in the following chapters we will explain how to
have a more advanced repl experience with code-highlighting, code-completion and
multiline edition.</simpara>
</note>
</section>
<section id="node-js-repl">
<title>Node.js REPL</title>
<simpara>You must, of course, have nodejs installed on your system to use this REPL.</simpara>
<simpara>You may be wondering why we might want a nodejs REPL, when we already have the
nashorn REPL available which doesn&#8217;t have any external dependencies. The answer is
very simple: nodejs is the most used JavaScript execution environment on the backend,
and it has a great number of community packages built around it.</simpara>
<simpara>The good news is that starting a nodejs REPL is very easy once you have it installed
in your system. Start adding the following content into <literal>tools.clj</literal> script:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.repl.node :as node])

(defmethod task "node:repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "out/nodejs"
             :cache-analysis true))</programlisting>
<simpara>And start the REPL:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clj tools.clj repl:node
ClojureScript 1.10.520
cljs.user=&gt; (prn "Hello world")
"Hello world"
nil</programlisting>
</section>
<section id="browser-repl">
<title>Browser REPL</title>
<simpara>This REPL is the most laborious to get up and running. This is because it uses a
browser for its execution environment and it has additional requirements.</simpara>
<simpara>Let’s start by adding the following content to the <literal>tools.clj</literal> script file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.build.api :as b])
(require '[cljs.repl.browser :as browser])

(defmethod task "repl:browser"
  [args]
  (println "Building...")
  (b/build "src"
           {:output-to "out/browser/main.js"
            :output-dir "out/browser"
            :source-map true
            :main 'myapp.core
            :optimizations :none})

  (println "Launching REPL...")
  (repl/repl (browser/repl-env :port 9001)
             :output-dir "out/browser"))</programlisting>
<simpara>The main difference with the previous examples, is that browser REPL requires
that some code be execution in the browser before the REPL gets working. To do
that, just re-create the application structure very similar to the one that we
have used in previous sections:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p src/myapp
touch src/myapp/core.cljs</programlisting>
<simpara>Then, write new content to the <literal>src/myapp/core.cljs</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9001/repl"))

(enable-console-print!)

(println "Hello, world!")</programlisting>
<simpara>And finally, create the missing <emphasis>index.html</emphasis> file that is going to be used as
the entry point for running the browser side code of the REPL:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="out/browser/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>
<simpara>Well, that was a lot of setup! But trust us, it’s all worth it when you see it in
action. To do that, just execute the <literal>tools.clj</literal> in the same way that we have done
it in previous examples:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clj tools.clj repl:browser
Building...
Launching REPL...
ClojureScript 1.10.520
cljs.user=&gt;</programlisting>
<simpara>And finally, open your favourite browser and go to <ulink url="http://localhost:9001/">http://localhost:9001/</ulink>. Once the
page is loaded (the page will be blank), switch back to the console where you have
run the REPL and you will see that it is up and running:</simpara>
<programlisting language="bash" linenumbering="unnumbered">[...]
To quit, type: :cljs/quit
cljs.user=&gt; (+ 14 28)
42</programlisting>
<simpara>One of the big advantages of the browser REPL is that you have access to everything
in the browser environment. For example, type <literal>(js/alert "hello world")</literal> in the
REPL. This will cause the browser to display an alert box. Nice!</simpara>
<note>
<simpara>This is just a preview of how to use the builtin REPL capabilities of the
ClojureScript compiler. There are better and more user/developer friendly repl
environments with code-highlighting, code-completion and multiline edition (and
in case of web development, also with code hot reloading) that will be explained
in the following chapters.</simpara>
</note>
</section>
<section id="rebel-readline-repl-library">
<title>Rebel Readline (REPL library)</title>
<simpara>This is a library that adds more advanced features to the Clojure(Script)
builtin REPL and enables code-highlighting, code-completion and multiline
edition.</simpara>
<simpara>Let&#8217;s start adding rebel dependency into <literal>deps.edn</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src"]}</programlisting>
<simpara>And adding the followin code to the <literal>tools.clj</literal> script file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[rebel-readline.core]
         '[rebel-readline.clojure.main]
         '[rebel-readline.clojure.line-reader]
         '[rebel-readline.cljs.service.local]
         '[rebel-readline.cljs.repl])

(defmethod task "repl:rebel:node"
  [args]
  (rebel-readline.core/with-line-reader
    (rebel-readline.clojure.line-reader/create
     (rebel-readline.cljs.service.local/create))
    (repl/repl (node/repl-env)
               :prompt (fn [])
               :read (rebel-readline.cljs.repl/create-repl-read)
               :output-dir "out/nodejs"
               :cache-analysis true)))</programlisting>
<simpara>And start the REPL:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clojure tools.clj repl:rebel:node
ClojureScript 1.10.520
cljs.user=&gt; (println
cljs.core/println: ([&amp; objs])</programlisting>
<simpara>You can find that while you writing in the repl, it automatically suggest and
shows se function signature that you want to execute.</simpara>
<simpara>You can find more information about all rebel-readline capabilities on
<ulink url="https://github.com/bhauman/rebel-readline">https://github.com/bhauman/rebel-readline</ulink></simpara>
</section>
</section>
<section id="the-closure-library">
<title>The Closure Library</title>
<simpara>The Google Closure Library is a javascript library developed by Google. It has a
modular architecture, and provides cross-browser functions for DOM manipulations and
events, ajax and JSON, and other features.</simpara>
<simpara>The Google Closure Library is written specifically to take advantage of the Closure
Compiler (which is used internally by the <emphasis>ClojureScript</emphasis> compiler).</simpara>
<simpara><emphasis>ClojureScript</emphasis> is built on the Google Closure Compiler and Closure Library. In fact,
<emphasis>ClojureScript</emphasis> namespaces are Closure modules. This means that you can interact with
the Closure Library very easily:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))</programlisting>
<simpara>This code snippet shows how you can import the <emphasis role="strong">dom</emphasis> module of the Closure library
and use a function declared in that module.</simpara>
<simpara>Additionally, the closure library exposes "special" modules that behave like a class
or object. To use these features, you must use the <literal>:import</literal> directive in the <literal>(ns
&#8230;&#8203;)</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns yourapp.core
  (:import goog.History))

(def instance (History.))</programlisting>
<simpara>In a <emphasis>Clojure</emphasis> program, the <literal>:import</literal> directive is used for host (Java) interop to
import Java classes.  If, however, you define types (classes) in <emphasis>ClojureScript</emphasis>, you
should use the standard <literal>:require</literal> directive and not the <literal>:import</literal> directive.</simpara>
<simpara>You can found the reference to all namespaces in the closure library here:
<ulink url="http://google.github.io/closure-library/api/">http://google.github.io/closure-library/api/</ulink></simpara>
</section>
<section id="dependency-management">
<title>Dependency management</title>
<simpara>Until now, we have used the builtin <emphasis>Clojure(Script)</emphasis> toolchain to compile our
source files to JavaScript. Now this is a time to understand how manage external
and/or third party dependencies.</simpara>
<section id="first-project">
<title>First project</title>
<simpara>The best way to show how a tool works is by creating a toy project with it. In
this case, we will create a small application that determines if a year is a
leap year or not.</simpara>
<simpara>Let&#8217;s start creating the project layout:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p leapyears/src/leapyears
mkdir -p leapyears/target/public
touch leapyears/target/public/index.html
touch leapyears/src/leapyears/core.cljs
touch leapyears/tools.cljs
touch leapyears/deps.edn</programlisting>
<simpara>The project has the following structure:</simpara>
<screen>leapyears
├── deps.edn
├── src
│   └── leapyears
│       └── core.cljs
├── target
│   └── public
│       └── index.html
└── tools.clj</screen>
<simpara>The <literal>deps.edn</literal> file contains information about all the <emphasis role="strong">packaged</emphasis> dependencies
needed to build or execute the application. Packaged dependencies are libraries
packaged as jar files and uploaded to clojars/maven repository.</simpara>
<note>
<simpara>But ClojureScript can consume external code in many different ways:</simpara>
<itemizedlist>
<listitem>
<simpara>google closure library module</simpara>
</listitem>
<listitem>
<simpara>global export module</simpara>
</listitem>
<listitem>
<simpara>es6/commonjs module (experimental)</simpara>
</listitem>
</itemizedlist>
<simpara>This will be explained in the following sections.</simpara>
</note>
<simpara>Let&#8217;s start with a simple <literal>deps.edn</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src" "target"]}</programlisting>
<simpara>And simple build script (<literal>tools.clj</literal> file):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.build.api :as b])
(require '[cljs.repl :as repl])
(require '[cljs.repl.node :as node])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-&gt; task methods (dissoc :default) keys sort)
        interposed (-&gt;&gt; all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "target/nodejs"
             :cache-analysis true))

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch "src" build-opts))

(task *command-line-args*)</programlisting>
<simpara>Then, write the following content into <literal>target/public/index.html</literal> file:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;leapyears&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;section class="viewport"&gt;
      &lt;div id="result"&gt;
        ----
      &lt;/div&gt;

      &lt;form action="" method=""&gt;
        &lt;label for="year"&gt;Input a year&lt;/label&gt;
        &lt;input id="year" name="year" /&gt;
      &lt;/form&gt;
    &lt;/section&gt;

    &lt;script src="./js/leapyears.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>
<simpara>The next step consist in add some code to make the form interactive. Put the
following code into the <literal>src/leapyears/core.cljs</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cljs.reader :refer (read-string)]))

(enable-console-print!)

(def input (dom/getElement "year"))
(def result (dom/getElement "result"))

(defn leap?
  [year]
  (or (zero? (js-mod year 400))
      (and (pos? (js-mod year 100))
           (zero? (js-mod year 4)))))

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]
    (if (leap? value)
      (set! (.-innerHTML result) "YES")
      (set! (.-innerHTML result) "NO"))))

(events/listen input "keyup" on-change)</programlisting>
<simpara>Now, we can compile the project with:</simpara>
<programlisting language="bash" linenumbering="unnumbered">clojure tools.clj watch</programlisting>
<simpara>Finally, open the <literal>target/public/index.html</literal> file in a browser. Typing a year in the textbox
should display an indication of its leap year status.</simpara>
</section>
<section id="adding-native-dependencies">
<title>Adding native dependencies</title>
<simpara>Until now we have used only the batteries included in the ClojureScript runtime,
let improve our project including a native dependency. In this example we will
use the <ulink url="https://github.com/funcool/cuerdas">Cuerdas</ulink> (a string manipulation
library build especifically for Clojure(Script)).</simpara>
<simpara>Add <literal>funcool/cuerdas {:mvn/version "2.2.0"}</literal> into the <literal>:deps</literal> section inside the
<literal>deps.edn</literal> file. And add the corresponding modifications to the
<literal>leapyears/core.cljs</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cuerdas.core :as str]
            [cljs.reader :refer (read-string)]))

;; [...]

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]

    (if (str/blank? value)
      (set! (.-innerHTML result) "---")
      (if (leap? value)
        (set! (.-innerHTML result) "YES")
        (set! (.-innerHTML result) "NO")))))</programlisting>
<simpara>Now, if you run the build or watch command, the new declared dependency will be
downloaded and the application will be compiled with this dependency included.</simpara>
<simpara>Clojure packages are often published on <ulink url="http://clojars.org">Clojars</ulink>. You can
also find many third party libraries on the
<ulink url="https://github.com/clojure/clojurescript/wiki#libraries">ClojureScript Wiki</ulink>.</simpara>
</section>
<section id="external-dependencies">
<title>External dependencies</title>
<simpara>In some circumstances you may found yourself that you need some library but that
does not exists in <emphasis>ClojureScript</emphasis> but it is already implemented in javascript
and you want to use it on your project.</simpara>
<simpara>There are many ways that you can do it mainly depending on the library that you
want to include. Many of that libraries are packaged and uploaded to clojars, so
you can declare them in the <literal>deps.edn</literal> in the same way as native dependencies
(with some peculirities in usage, see below).</simpara>
</section>
<section id="closure-compatible-module">
<title>Closure compatible module</title>
<simpara>If you have a library that is written to be compatible with google closure
module system and you want to include it on your project: put the source into
the classpath (inside <literal>src</literal> or <literal>vendor</literal> directory in leapyears project) and
access it like any other clojure namespace.</simpara>
<simpara>This is the most simplest case, because google closure modules are directly
compatible and you can mix your clojure code with javascript code written using
google closure module system without any additional steps.</simpara>
<simpara>Reusing the leapyears project, lets implement the <literal>leap?</literal> function in
a javascript using google closure module format. Start creating the
directory structure:</simpara>
<programlisting language="bash" linenumbering="unnumbered">touch src/leapyears/util.js</programlisting>
<simpara>And add the implementation using closure module format:</simpara>
<formalpara>
<title>src/leapyears/util.js</title>
<para>
<programlisting language="js" linenumbering="unnumbered">goog.provide("leapyears.util");

goog.scope(function() {
  var module = leapyears.util;

  module.isLeap = function(val) {
    return (0 === (val % 400)) || (((val % 100) &gt; 0) &amp;&amp; (0 === (val % 4)));
  };
});</programlisting>
</para>
</formalpara>
<simpara>Now, if you open the repl, you can import the namespace and use the <literal>isLeap</literal>
function</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[leapyears.util :as util])

(util/isLeap 2112)
;; =&gt; true

(util/isLeap 211)
;; =&gt; false</programlisting>
<note>
<simpara>you can open the nodejs repl just executing <literal>clj tools.clj repl</literal> in the
root of the project.</simpara>
</note>
<note>
<simpara>this is the approach used by many projects to implement some performance
sensitive logic directly in javascript and export it in an easy way to
ClojureScript</simpara>
</note>
</section>
<section id="global-export">
<title>Global Export</title>
<simpara>This is the most extended and the most reliable way to consume external
javascript libraries from ClojureScript and it has many facilities.</simpara>
<simpara>Let&#8217;s play with that. Start creating a simple file using commonjs module format
(pretty analogous to the previous example using google closure modules):</simpara>
<simpara>The fastest way to include a javascript library is looking if it is available in
<ulink url="http://cljsjs.github.io/">CLJSJS</ulink>. If it is available, just include the
dependency in the <literal>deps.edn</literal> file and use it.</simpara>
<simpara>That libraries has two ways of use it, let&#8217;s see some examples.</simpara>
<simpara>Start adding <literal>moment</literal> dependency to <literal>deps.edn</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">cljsjs/moment {:mvn/version "2.24.0-0"}</programlisting>
<simpara>Then, open the repl and try the following:</simpara>
<formalpara>
<title>using the <literal>js/</literal> special namespace</title>
<para>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljsjs.moment]) ;; just require, no alias

(.format (js/moment) "LLLL")
;; =&gt; "Monday, July 15, 2019 5:32 PM"</programlisting>
</para>
</formalpara>
<formalpara>
<title>using the alias</title>
<para>
<programlisting language="clojure" linenumbering="unnumbered">(require '[moment :as m])

(.format (m) "LLLL")
;; =&gt; "Monday, July 15, 2019 5:33 PM"</programlisting>
</para>
</formalpara>
<simpara>Behind the scenes that packages uses the ClojureScript compiler facilities
<ulink url="https://clojurescript.org/reference/compiler-options#foreign-libs">descibed
here</ulink> for provide the compiler with enough information about the files and
global exports to use.</simpara>
<simpara>So, if don&#8217;t find a library in cljsjs, we can include it using the same
facilities. Let&#8217;s assume that moment is not available on cljsjs and we need it
on our project.</simpara>
<simpara>For include an foreign dependency we need to pass <literal>:foreign-libs</literal> and <literal>:externs</literal>
params to the ClojureScript compiler, and we have two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>passing them to the <literal>build</literal> or <literal>repl</literal> functions.</simpara>
</listitem>
<listitem>
<simpara>inside the <literal>deps.cljs</literal> file located on the root of the classpath.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>deps.cljs</literal> approach requires that files should be localted on the local
directories, but the first approach allows specify directly external urls. We
will use the first approach on our example.</simpara>
<simpara>This is how looks the <literal>deps.edn</literal> file with the changes applied:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; [...]

(def foreign-libs
  [{:file "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"
    :file-min "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"
    :provides ["vendor.moment"]}])


(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none
   :foreign-libs foreign-libs})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :foreign-libs foreign-libs
             :output-dir "target/node"
             :cache-analysis true))

;; [...]</programlisting>
<simpara>Now, if you excute the repl, you will be able to import <literal>vendor.moment</literal> in the same way
if you are using the cljsjs package.</simpara>
<simpara>Finally, there are the <literal>:externs</literal> option, that will be needed only for the
production build, and the externs file consists in plain javascript files that
declares the public API of the included foreign libraries and make them
understandable to the google closure compiler.</simpara>
<simpara>The moment externs are available
<ulink url="https://github.com/cljsjs/packages/blob/master/moment/resources/cljsjs/common/moment.ext.js">here</ulink>
and if you include some library that you want to use, and then want to compile
your app with advanced optimizations you will need to include a file similar to
the moment.ext.js on the project and referenciate it with <literal>:externs</literal> option to
the ClojureScript compiler.</simpara>
<simpara>More info <ulink url="https://clojurescript.org/reference/compiler-options#externs">on clojurescript.org</ulink>.</simpara>
</section>
<section id="es6commonjs-modules">
<title>ES6/CommonJS modules</title>
<simpara>Google Closure Compiler has an advanced feature that allows convert from
different module types (commonjs and ES) into google closure module
type. Although this feature is still experimental. With simple modules it works,
but with more complex modules (many submodules and directories) still doest
not complies correctly.</simpara>
<simpara>In any way I invite you to experiment with it. You can found more documentation
on
<ulink url="https://clojurescript.org/reference/javascript-module-support">clojurescript.org</ulink>.</simpara>
<simpara>The best way to use ES6 and/or CommonJS module is combining a javascript bundler
like <emphasis>rollup</emphasis> or <emphasis>webpack</emphasis> to generate a single build with external dependencies
and thn use the <emphasis role="strong">global exports</emphasis> method to use it in ClojureScript. An example
of this is explained <ulink url="https://clojurescript.org/guides/webpack">on clojurescript.org</ulink>.</simpara>
</section>
</section>
<section id="interactive-development-with-figwheel">
<title>Interactive development with Figwheel</title>
<simpara>And finally we will introduce <emphasis role="strong">figwheel</emphasis>, that enables fully interactive,
REPL-based and hot reloading enabled development environment.</simpara>
<simpara>We will reuse the leapyears project structure for the following examples.</simpara>
<note>
<simpara>Although we use figwheel here for web application, it works in the same
way on the application that targets nodejs as execution environment.</simpara>
</note>
<simpara>As first step, we need to add <emphasis role="strong">figwheel</emphasis> dependency to the <literal>deps.edn</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">com.bhauman/figwheel-main {:mvn/version "0.2.1"}</programlisting>
<simpara>Then, add new task to the <literal>tools.clj</literal> script:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def figwheel-opts
  {:open-url false
   :load-warninged-code true
   :auto-testing false
   :ring-server-options {:port 3448 :host "0.0.0.0"}
   :watch-dirs ["src"]})

(defmethod task "figwheel"
  [args]
  (figwheel/start figwheel-opts {:id "main" :options build-opts}))</programlisting>
<simpara>And then, run <literal>clojure tools.clj fighweel</literal>. This will start the figwheel process
that automatically will launch a http server that will serve the
<literal>target/public/</literal> directory and index to <literal>index.html</literal> file.</simpara>
<simpara>If you update the code, that code will be automatically loaded to the browser,
<emphasis role="strong">without page reload</emphasis>.</simpara>
<simpara>For more info: <ulink url="https://figwheel.org/">figwheel.org</ulink>.</simpara>
</section>
<section id="unit-testing">
<title>Unit testing</title>
<simpara>As you might expect, testing in <emphasis>ClojureScript</emphasis> consists of the same concepts widely
used by other language such as Clojure, Java, Python, JavaScript, etc.</simpara>
<simpara>Regardless of the language, the main objective of unit testing is to run some test
cases, verifying that the code under test behaves as expected and returns without
raising unexpected exceptions.</simpara>
<simpara>The immutablity of <emphasis>ClojureScript</emphasis> data structures helps to make programs less error
prone, and facilitates testing a little bit. Another advantage of <emphasis>ClojureScript</emphasis> is
that it tends to use plain data instead of complex objects. Building "mock" objects
for testing is thus greatly simplified.</simpara>
<section id="first-steps">
<title>First steps</title>
<simpara>The "official" <emphasis>ClojureScript</emphasis> testing framework is in the "cljs.test" namespace. It
is a very simple library, but it should be more than enough for our purposes.</simpara>
<simpara>There are other libraries that offer additional features or directly different
approaches to testing, such as
<ulink url="https://github.com/clojure/test.check">test.check</ulink>. However, we will not cover
them here.</simpara>
<simpara>We will reuse the <literal>leapyears</literal> project structure and we will add testing to it. Let&#8217;s create
the test related files and directories:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p test/leapyears/test
touch test/leapyears/test/main.cljs</programlisting>
<simpara>Also we will need to create new tasks on our <literal>tools.clj</literal> file for build, watch and run
tests:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[clojure.java.shell :as shell])

;; [...]

(defmethod task "build:tests"
  [args]
  (b/build (b/inputs "src" "vendor" "test")
           (assoc build-opts
                  :main 'leapyears.test.main
                  :output-to "out/tests.js"
                  :output-dir "out/tests"
                  :target :nodejs)))

(defmethod task "watch:test"
  [args]
  (letfn [(run-tests []
            (let [{:keys [out err]} (shell/sh "node" "out/tests.js")]
              (println out err)))]
    (println "Start watch loop...")
    (try
      (b/watch (b/inputs "src", "test")
               (assoc build-opts
                      :main 'leapyears.test.main
                      :watch-fn run-tests
                      :output-to "out/tests.js"
                      :output-dir "out/tests"
                      :target :nodejs))

      (catch Exception e
        (println "Error on running tests:" e)
        ;; (Thread/sleep 2000)
        (task args)))))</programlisting>
<simpara>Next, put some test code in the <literal>test/leapyears/test/main.cljs</literal> file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns leapyears.test.main
  (:require [cljs.test :as t]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (= 1 2)))

(set! *main-cli-fn* #(t/run-tests))

;; This extension is required for correctly set the return code
;; depending if the test passes or not.
(defmethod t/report [:cljs.test/default :end-run-tests]
  [m]
  (if (t/successful? m)
    (set! (.-exitCode js/process) 0)
    (set! (.-exitCode js/process) 1)))</programlisting>
<simpara>The relevant part of that code snippet is:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(t/deftest my-first-test
  (t/is (= 1 2)))</programlisting>
<simpara>The <literal>deftest</literal> macro is a basic primitive for defining our tests. It takes a name as
its first parameter, followed by one or multiple assertions using the <literal>is</literal> macro. In
this example, we try to assert that <literal>(= 1 2)</literal> is true.</simpara>
<simpara>Let&#8217;s try to run this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clojure tools build:tests
$ node out/tests.js
Testing mytestingapp.core-tests

FAIL in (my-first-test) (cljs/test.js:374:14)
expected: (= 1 2)
  actual: (not (= 1 2))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.</programlisting>
<simpara>You can see that the expected assert failure is successfully printed in the
console. To fix the test, just change the <literal>=</literal> with <literal>not=</literal> and run the file again:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ clojure tools build:tests
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.</programlisting>
<simpara>It is fine to test these kinds of assertions, but they are not very
useful. Let&#8217;s go to test some application code. For this, we will use a function
to check if a year is a leap year or not:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns leapyears.test.main
  (:require [cljs.test :as t]
            [leapyears.vendor.util-closure :as util]))

;; [...]

(t/deftest my-second-test
  (t/is (util/isLeap 1980))
  (t/is (not (util/isLeap 1981))))

;; [...]</programlisting>
<simpara>Run the compiled file again to see that there are now two tests running.  The
first test passes as before, and our two new leap year tests pass as well.</simpara>
</section>
<section id="async-testing">
<title>Async Testing</title>
<simpara>One of the peculiarities of <emphasis>ClojureScript</emphasis> is that it runs in an asynchronous,
single-threaded execution environment, which has its challenges.</simpara>
<simpara>In an async execution environment, we should be able to test asynchronous functions.
To this end, the <emphasis>ClojureScript</emphasis> testing library offers the <literal>async</literal> macro, allowing
you to create tests that play well with asynchronous code.</simpara>
<simpara>First, we need to write a function that works in an asynchronous way. For this
purpose, we will create the <literal>async-leap?</literal> predicate that will do the same operation
but asychronously return a result using a callback:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn async-leap?
  [year callback]
  (js/setImmediate #(callback (util/isLeap year))))</programlisting>
<simpara>The JavaScript function <literal>setImmediate</literal> is used to emulate an asynchronous task, and
the callback is executed with the result of that predicate.</simpara>
<simpara>To test it, we should write a test case using the previously mentioned <literal>async</literal> macro:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(t/deftest my-async-test
  (t/async done
    (async-leap? 1980 (fn [result]
                        (t/is (true? result))
                              (done)))))</programlisting>
<simpara>The <literal>done</literal> function exposed by the <literal>async</literal> macro should be called after the
asynchronous operation is finished and all assertions have run.</simpara>
<simpara>It is very important to execute the <literal>done</literal> function only once. Omitting it or
executing it twice may cause strange behavior and should be avoided.</simpara>
</section>
</section>
</chapter>
<chapter id="language-advanced-topics">
<title>Language (advanced topics)</title>
<simpara>This chapter intends to explain some advanced topics that are part of the language
and that does not fit in the first chapter. The good candidates for this section are
transducers, core protocols, transients, metadata. In summary: topics that are not
mandatory for understand the language.</simpara>
<section id="transducers">
<title>Transducers</title>
<section id="data-transformation">
<title>Data transformation</title>
<simpara>ClojureScript offers a rich vocabulary for data transformation in terms of the
sequence abstraction, which makes such transformations highly general and
composable. Let&#8217;s see how we can combine several collection processing functions to
build new ones. We will be using a simple problem throughout this section: splitting
grape clusters, filtering out the rotten ones, and cleaning them. We have a
collection of grape clusters like the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def grape-clusters
  [{:grapes [{:rotten? false :clean? false}
             {:rotten? true :clean? false}]
    :color :green}
   {:grapes [{:rotten? true :clean? false}
             {:rotten? false :clean? false}]
    :color :black}])</programlisting>
<simpara>We are interested in splitting the grape clusters into individual grapes, discarding
the rotten ones and cleaning the remaining grapes so they are ready for eating. We
are well-equipped in ClojureScript for this data transformation task; we could
implement it using the familiar <literal>map</literal>, <literal>filter</literal> and <literal>mapcat</literal> functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn split-cluster
  [c]
  (:grapes c))

(defn not-rotten
  [g]
  (not (:rotten? g)))

(defn clean-grape
  [g]
  (assoc g :clean? true))

(-&gt;&gt; grape-clusters
     (mapcat split-cluster)
     (filter not-rotten)
     (map clean-grape))
;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</programlisting>
<simpara>In the above example we succintly solved the problem of selecting and cleaning the
grapes, and we can even abstract such transformations by combining the <literal>mapcat</literal>,
<literal>filter</literal> and <literal>map</literal> operations using partial application and function composition:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def process-clusters
  (comp
    (partial map clean-grape)
    (partial filter not-rotten)
    (partial mapcat split-cluster)))

(process-clusters grape-clusters)
;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</programlisting>
<simpara>The code is very clean, but it has a few problems. For example, each call to <literal>map</literal>,
<literal>filter</literal> and <literal>mapcat</literal> consumes and produces a sequence that, although lazy, generates
intermediate results that will be discarded. Each sequence is fed to the next step,
which also returns a sequence. Wouldn&#8217;t be great if we could do the transformation in
a single transversal of the <literal>grape-cluster</literal> collection?</simpara>
<simpara>Another problem is that even though our <literal>process-clusters</literal> function works with any
sequence, we can&#8217;t reuse it with anything that is not a sequence. Imagine that
instead of having the grape cluster collection available in memory it is being pushed
to us asynchronously in a stream. In that situation we couldn&#8217;t reuse
<literal>process-clusters</literal> since usually <literal>map</literal>, <literal>filter</literal> and <literal>mapcat</literal> have concrete
implementations depending on the type.</simpara>
</section>
<section id="generalizing-to-process-transformations">
<title>Generalizing to process transformations</title>
<simpara>The process of mapping, filtering or mapcatting isn&#8217;t necessarily tied to a concrete
type, but we keep reimplementing them for different types. Let&#8217;s see how we can
generalize such processes to be context independent. We&#8217;ll start by implementing
naive versions of <literal>map</literal> and <literal>filter</literal> first to see how they work internally:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-map
  [f coll]
  (when-let [s (seq coll)]
    (cons (f (first s)) (my-map f (rest s)))))

(my-map inc [0 1 2])
;; =&gt; (1 2 3)

(defn my-filter
  [pred coll]
  (when-let [s (seq coll)]
    (let [f (first s)
          r (rest s)]
      (if (pred f)
        (cons f (my-filter pred r))
        (my-filter pred r)))))

(my-filter odd? [0 1 2])
;; =&gt; (1)</programlisting>
<simpara>As we can see, they both assume that they receive a seqable and return a
sequence. Like many recursive functions they can be implemented in terms of the
already familiar <literal>reduce</literal> function. Note that functions that are given to reduce
receive an accumulator and an input and return the next accumulator. We&#8217;ll call these
types of functions reducing functions from now on.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-mapr
  [f coll]
  (reduce (fn [acc input]         ;; reducing function
            (conj acc (f input)))
          []                      ;; initial value
          coll))                  ;; collection to reduce

(my-mapr inc [0 1 2])
;; =&gt; [1 2 3]

(defn my-filterr
  [pred coll]
  (reduce (fn [acc input]         ;; reducing function
            (if (pred input)
              (conj acc input)
              acc))
          []                      ;; initial value
          coll))                  ;; collection to reduce

(my-filterr odd? [0 1 2])
;; =&gt; [1]</programlisting>
<simpara>We&#8217;ve made the previous versions more general since using <literal>reduce</literal> makes our
functions work on any thing that is reducible, not just sequences. However you may
have noticed that, even though <literal>my-mapr</literal> and <literal>my-filterr</literal> don&#8217;t know anything about
the source (<literal>coll</literal>) they are still tied to the output they produce (a vector) both
with the initial value of the reduce (<literal>[]</literal>) and the hardcoded <literal>conj</literal> operation in the
body of the reducing function. We could have accumulated results in another data
structure, for example a lazy sequence, but we&#8217;d have to rewrite the functions in
order to do so.</simpara>
<simpara>How can we make these functions truly generic? They shouldn&#8217;t know about either the
source of inputs they are transforming nor the output that is generated. Have you
noticed that <literal>conj</literal> is just another reducing function? It takes an accumulator and an
input and returns another accumulator. So, if we parameterise the reducing function
that <literal>my-mapr</literal> and <literal>my-filterr</literal> use, they won&#8217;t know anything about the type of the
result they are building. Let&#8217;s give it a shot:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-mapt
  [f]                         ;; function to map over inputs
  (fn [rfn]                   ;; parameterised reducing function
    (fn [acc input]           ;; transformed reducing function, now it maps `f`!
      (rfn acc (f input)))))

(def incer (my-mapt inc))

(reduce (incer conj) [] [0 1 2])
;; =&gt; [1 2 3]

(defn my-filtert
  [pred]                      ;; predicate to filter out inputs
  (fn [rfn]                   ;; parameterised reducing function
    (fn [acc input]           ;; transformed reducing function, now it discards values based on `pred`!
      (if (pred input)
        (rfn acc input)
        acc))))

(def only-odds (my-filtert odd?))

(reduce (only-odds conj) [] [0 1 2])
;; =&gt; [1]</programlisting>
<simpara>That&#8217;s a lot of higher-order functions so let&#8217;s break it down for a better
understanding of what&#8217;s going on. We&#8217;ll examine how <literal>my-mapt</literal> works step by
step. The mechanics are similar for <literal>my-filtert</literal>, so we&#8217;ll leave it out for now.</simpara>
<simpara>First of all, <literal>my-mapt</literal> takes a mapping function; in the example we are giving
it <literal>inc</literal> and getting another function back. Let&#8217;s replace <literal>f</literal> with <literal>inc</literal> to see
what we are building:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def incer (my-mapt inc))
;; (fn [rfn]
;;   (fn [acc input]
;;     (rfn acc (inc input))))
;;               ^^^</programlisting>
<simpara>The resulting function is still parameterised to receive a reducing function to
which it will delegate, let&#8217;s see what happens when we call it with <literal>conj</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(incer conj)
;; (fn [acc input]
;;   (conj acc (inc input)))
;;    ^^^^</programlisting>
<simpara>We get back a reducing function which uses <literal>inc</literal> to transform the inputs and the
<literal>conj</literal> reducing function to accumulate the results. In essence, we have defined
map as the transformation of a reducing function.  The functions that transform
one reducing function into another are called transducers in ClojureScript.</simpara>
<simpara>To ilustrate the generality of transducers, let&#8217;s use different sources and
destinations in our call to <literal>reduce</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce (incer str) "" [0 1 2])
;; =&gt; "123"

(reduce (only-odds str) "" '(0 1 2))
;; =&gt; "1"</programlisting>
<simpara>The transducer versions of <literal>map</literal> and <literal>filter</literal> transform a process that carries
inputs from a source to a destination but don&#8217;t know anything about where the
inputs come from and where they end up. In their implementation they contain the
<emphasis>essence</emphasis> of what they accomplish, independent of context.</simpara>
<simpara>Now that we know more about transducers we can try to implement our own version
of <literal>mapcat</literal>. We already have a fundamental piece of it: the <literal>map</literal>
transducer. What <literal>mapcat</literal> does is map a function over an input and flatten the
resulting structure one level. Let&#8217;s try to implement the catenation part as a
transducer:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-cat
  [rfn]
  (fn [acc input]
    (reduce rfn acc input)))

(reduce (my-cat conj) [] [[0 1 2] [3 4 5]])
;; =&gt; [0 1 2 3 4 5]</programlisting>
<simpara>The <literal>my-cat</literal> transducer returns a reducing function that catenates its inputs
into the accumulator. It does so reducing the <literal>input</literal> reducible with the <literal>rfn</literal>
reducing function and using the accumulator (<literal>acc</literal>) as the initial value for
such reduction. <literal>mapcat</literal> is simply the composition of <literal>map</literal> and <literal>cat</literal>. The order
in which transducers are composed may seem backwards but it&#8217;ll become clear in a
moment.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-mapcat
  [f]
  (comp (my-mapt f) my-cat))

(defn dupe
  [x]
  [x x])

(def duper (my-mapcat dupe))

(reduce (duper conj) [] [0 1 2])
;; =&gt; [0 0 1 1 2 2]</programlisting>
</section>
<section id="transducers-in-clojurescript-core">
<title>Transducers in ClojureScript core</title>
<simpara>Some of the ClojureScript core functions like <literal>map</literal>, <literal>filter</literal> and <literal>mapcat</literal>
support an arity 1 version that returns a transducer. Let&#8217;s revisit our
definition of <literal>process-cluster</literal> and define it in terms of transducers:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def process-clusters
  (comp
    (mapcat split-cluster)
    (filter not-rotten)
    (map clean-grape)))</programlisting>
<simpara>A few things changed since our previous definition <literal>process-clusters</literal>. First of
all, we are using the transducer-returning versions of <literal>mapcat</literal>, <literal>filter</literal> and
<literal>map</literal> instead of partially applying them for working on sequences.</simpara>
<simpara>Also you may have noticed that the order in which they are composed is reversed,
they appear in the order they are executed. Note that all <literal>map</literal>, <literal>filter</literal> and
<literal>mapcat</literal> return a transducer. <literal>filter</literal> transforms the reducing function returned
by <literal>map</literal>, applying the filtering before proceeding; <literal>mapcat</literal> transforms the
reducing function returned by <literal>filter</literal>, applying the mapping and catenation
before proceeding.</simpara>
<simpara>One of the powerful properties of transducers is that they are combined using
regular function composition.  What&#8217;s even more elegant is that the composition
of various transducers is itself a transducer! This means that our
<literal>process-cluster</literal> is a transducer too, so we have defined a composable and
context-independent algorithmic transformation.</simpara>
<simpara>Many of the core ClojureScript functions accept a transducer, let&#8217;s look at some
examples with our newly created <literal>process-cluster</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(into [] process-clusters grape-clusters)
;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]

(sequence process-clusters grape-clusters)
;; =&gt; ({:rotten? false, :clean? true} {:rotten? false, :clean? true})

(reduce (process-clusters conj) [] grape-clusters)
;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</programlisting>
<simpara>Since using <literal>reduce</literal> with the reducing function returned from a transducer is so
common, there is a function for reducing with a transformation called
<literal>transduce</literal>. We can now rewrite the previous call to <literal>reduce</literal> using <literal>transduce</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(transduce process-clusters conj [] grape-clusters)
;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</programlisting>
</section>
<section id="initialisation">
<title>Initialisation</title>
<simpara>In the last example we provided an initial value to the <literal>transduce</literal> function
(<literal>[]</literal>) but we can omit it and get the same result:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(transduce process-clusters conj grape-clusters)
;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</programlisting>
<simpara>What&#8217;s going on here? How can <literal>transduce</literal> know what initial value use as an
accumulator when we haven&#8217;t specified it? Try calling <literal>conj</literal> without any arguments
and see what happens:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(conj)
;; =&gt; []</programlisting>
<simpara>The <literal>conj</literal> function has a arity 0 version that returns an empty vector but is
not the only reducing function that supports arity 0. Let&#8217;s explore some others:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+)
;; =&gt; 0

(*)
;; =&gt; 1

(str)
;; =&gt; ""

(= identity (comp))
;; =&gt; true</programlisting>
<simpara>The reducing function returned by transducers must support the arity 0 as well,
which will typically delegate to the transformed reducing function. There is no
sensible implementation of the arity 0 for the transducers we have implemented
so far, so we&#8217;ll simply call the reducing function without arguments. Here&#8217;s how
our modified <literal>my-mapt</literal> could look like:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-mapt
  [f]
  (fn [rfn]
    (fn
      ([] (rfn))                ;; arity 0 that delegates to the reducing fn
      ([acc input]
        (rfn acc (f input))))))</programlisting>
<simpara>The call to the arity 0 of the reducing function returned by a transducer will
call the arity 0 version of every nested reducing function, eventually calling
the outermost reducing function. Let&#8217;s see an example with our already defined
<literal>process-clusters</literal> transducer:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">((process-clusters conj))
;; =&gt; []</programlisting>
<simpara>The call to the arity 0 flows through the transducer stack, eventually calling
<literal>(conj)</literal>.</simpara>
</section>
<section id="stateful-transducers">
<title>Stateful transducers</title>
<simpara>So far we&#8217;ve only seen purely functional transducer; they don&#8217;t have any
implicit state and are very predictable. However, there are many data
transformation functions that are inherently stateful, like <literal>take</literal>. <literal>take</literal>
receives a number <literal>n</literal> of elements to keep and a collection and returns a
collection with at most <literal>n</literal> elements.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(take 10 (range 100))
;; =&gt; (0 1 2 3 4 5 6 7 8 9)</programlisting>
<simpara>Let&#8217;s step back for a bit and learn about the early termination of the <literal>reduce</literal>
function. We can wrap an accumulator in a type called <literal>reduced</literal> for telling
<literal>reduce</literal> that the reduction process should terminate immediately. Let&#8217;s see an
example of a reduction that aggregates the inputs in a collection and finishes
as soon as there are 10 elements in the accumulator:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce (fn [acc input]
          (if (= (count acc) 10)
            (reduced acc)
            (conj acc input)))
         []
         (range 100))
;; =&gt; [0 1 2 3 4 5 6 7 8 9]</programlisting>
<simpara>Since transducers are modifications of reducing functions they also use
<literal>reduced</literal> for early termination.  Note that stateful transducers may need to do
some cleanup before the process terminates, so they must support an arity 1 as a
"completion" step. Usually, like with arity 0, this arity will simply delegate
to the transformed reducing function&#8217;s arity 1.</simpara>
<simpara>Knowing this we are able to write stateful transducers like <literal>take</literal>. We&#8217;ll be
using mutable state internally for tracking the number of inputs we have seen so
far, and wrap the accumulator in a <literal>reduced</literal> as soon as we&#8217;ve seen enough
elements:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-take
  [n]
  (fn [rfn]
    (let [remaining (volatile! n)]
      (fn
        ([] (rfn))
        ([acc] (rfn acc))
        ([acc input]
          (let [rem @remaining
                nr (vswap! remaining dec)
                result (if (pos? rem)
                         (rfn acc input)   ;; we still have items to take
                         acc)]             ;; we're done, acc becomes the result
            (if (not (pos? nr))
              (ensure-reduced result)      ;; wrap result in reduced if not already
              result)))))))</programlisting>
<simpara>This is a simplified version of the <literal>take</literal> function present in ClojureScript
core. There are a few things to note here so let&#8217;s break it up in pieces to
understand it better.</simpara>
<simpara>The first thing to notice is that we are creating a mutable value inside the
transducer. Note that we don&#8217;t create it until we receive a reducing function to
transform. If we created it before returning the transducer we couldn&#8217;t use
<literal>my-take</literal> more than once. Since the transducer is handed a reducing function to
transform each time it is used, we can use it multiple times and the mutable
variable will be created in every use.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(fn [rfn]
  (let [remaining (volatile! n)] ;; make sure to create mutable variables inside the transducer
    (fn
      ;; ...
)))

(def take-five (my-take 5))

(transduce take-five conj (range 100))
;; =&gt; [0 1 2 3 4]

(transduce take-five conj (range 100))
;; =&gt; [0 1 2 3 4]</programlisting>
<simpara>Let&#8217;s now dig into the reducing function returned from <literal>my-take</literal>. First of all
we <literal>deref</literal> the volatile to get the number of elements that remain to be taken
and decrement it to get the next remaining value.  If there are still remaining
items to take, we call <literal>rfn</literal> passing the accumulator and input; if not, we
already have the final result.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">([acc input]
  (let [rem @remaining
        nr (vswap! remaining dec)
        result (if (pos? rem)
                 (rfn acc input)
                 acc)]
    ;; ...
))</programlisting>
<simpara>The body of <literal>my-take</literal> should be obvious by now. We check whether there are still
items to be processed using the next remainder (<literal>nr</literal>) and, if not, wrap the
result in a <literal>reduced</literal> using the <literal>ensure-reduced</literal> function. <literal>ensure-reduced</literal> will
wrap the value in a <literal>reduced</literal> if it&#8217;s not reduced already or simply return the
value if it&#8217;s already reduced. In case we are not done yet, we return the
accumulated <literal>result</literal> for further processing.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(if (not (pos? nr))
  (ensure-reduced result)
  result)</programlisting>
<simpara>We&#8217;ve seen an example of a stateful transducer but it didn&#8217;t do anything in its
completion step. Let&#8217;s see an example of a transducer that uses the completion
step to flush an accumulated value. We&#8217;ll implement a simplified version of
<literal>partition-all</literal>, which given a <literal>n</literal> number of elements converts the inputs in
vectors of size <literal>n</literal>. For understanding its purpose better let&#8217;s see what the
arity 2 version gives us when providing a number and a collection:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(partition-all 3 (range 10))
;; =&gt; ((0 1 2) (3 4 5) (6 7 8) (9))</programlisting>
<simpara>The transducer returning function of <literal>partition-all</literal> will take a number <literal>n</literal> and
return a transducer that groups inputs in vectors of size <literal>n</literal>. In the completion
step it will check if there is an accumulated result and, if so, add it to the
result. Here&#8217;s a simplified version of ClojureScript core <literal>partition-all</literal>
function, where <literal>array-list</literal> is a wrapper for a mutable JavaScript array:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-partition-all
  [n]
  (fn [rfn]
    (let [a (array-list)]
      (fn
        ([] (rfn))
        ([result]
          (let [result (if (.isEmpty a)                  ;; no inputs accumulated, don't have to modify result
                         result
                         (let [v (vec (.toArray a))]
                           (.clear a)                    ;; flush array contents for garbage collection
                           (unreduced (rfn result v))))] ;; pass to `rfn`, removing the reduced wrapper if present
            (rfn result)))
        ([acc input]
          (.add a input)
          (if (== n (.size a))                           ;; got enough results for a chunk
            (let [v (vec (.toArray a))]
              (.clear a)
              (rfn acc v))                               ;; the accumulated chunk becomes input to `rfn`
            acc))))))

(def triples (my-partition-all 3))

(transduce triples conj (range 10))
;; =&gt; [[0 1 2] [3 4 5] [6 7 8] [9]]</programlisting>
</section>
<section id="eductions">
<title>Eductions</title>
<simpara>Eductions are a way to combine a collection and one or more transformations that
can be reduced and iterated over, and that apply the transformations every time
we do so. If we have a collection that we want to process and a transformation
over it that we want others to extend, we can hand them a eduction,
encapsulating the source collection and our transformation. We can create an
eduction with the <literal>eduction</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ed (eduction (filter odd?) (take 5) (range 100)))

(reduce + 0 ed)
;; =&gt; 25

(transduce (partition-all 2) conj ed)
;; =&gt; [[1 3] [5 7] [9]]</programlisting>
</section>
<section id="more-transducers-in-clojurescript-core">
<title>More transducers in ClojureScript core</title>
<simpara>We learned about <literal>map</literal>, <literal>filter</literal>, <literal>mapcat</literal>, <literal>take</literal> and <literal>partition-all</literal>, but there are
a lot more transducers available in ClojureScript. Here is an incomplete list of some
other intersting ones:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>drop</literal> is the dual of <literal>take</literal>, dropping up to <literal>n</literal> values before passing inputs to
the reducing function</simpara>
</listitem>
<listitem>
<simpara><literal>distinct</literal> only allows inputs to occur once</simpara>
</listitem>
<listitem>
<simpara><literal>dedupe</literal> removes succesive duplicates in input values</simpara>
</listitem>
</itemizedlist>
<simpara>We encourage you to explore ClojureScript core to see what other transducers are out
there.</simpara>
</section>
<section id="defining-our-own-transducers">
<title>Defining our own transducers</title>
<simpara>There a few things to consider before writing our own transducers so in this
section we will learn how to properly implement one. First of all, we&#8217;ve learned
that the general structure of a transducer is the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(fn [xf]
  (fn
    ([]          ;; init
      ...)
    ([r]         ;; completion
      ...)
    ([acc input] ;; step
      ...)))</programlisting>
<simpara>Usually only the code represented with <literal>&#8230;&#8203;</literal> changes between transducers, these are
the invariants that must be preserved in each arity of the resulting function:</simpara>
<itemizedlist>
<listitem>
<simpara>arity 0 (init): must call the arity 0 of the nested transform <literal>xf</literal></simpara>
</listitem>
<listitem>
<simpara>arity 1 (completion): used to produce a final value and potentially flush state,
must call the arity 1 of the nested transform <literal>xf</literal> <emphasis role="strong">exactly once</emphasis></simpara>
</listitem>
<listitem>
<simpara>arity 2 (step): the resulting reducing function which will call the arity 2 of
the nested transform <literal>xf</literal> zero, one or more times</simpara>
</listitem>
</itemizedlist>
</section>
<section id="transducible-processes">
<title>Transducible processes</title>
<simpara>A transducible process is any process that is defined in terms of a succession
of steps ingesting input values.  The source of input varies from one process to
another. Most of our examples dealt with inputs from a collection or a lazy
sequence, but it could be an asynchronous stream of values or a <literal>core.async</literal>
channel. The outputs produced by each step are also different for every process;
<literal>into</literal> creates a collection with every output of the transducer, <literal>sequence</literal>
yields a lazy sequence, and asynchronous streams would probably push the outputs
to their listeners.</simpara>
<simpara>In order to improve our understanding of transducible processes, we&#8217;re going to
implement an unbounded queue, since adding values to a queue can be thought in
terms of a succession of steps ingesting input. First of all we&#8217;ll define a
protocol and a data type that implements the unbounded queue:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol Queue
  (put! [q item] "put an item into the queue")
  (take! [q] "take an item from the queue")
  (shutdown! [q] "stop accepting puts in the queue"))

(deftype UnboundedQueue [^:mutable arr ^:mutable closed]
  Queue
  (put! [_ item]
    (assert (not closed))
    (assert (not (nil? item)))
    (.push arr item)
    item)
  (take! [_]
    (aget (.splice arr 0 1) 0))
  (shutdown! [_]
    (set! closed true)))</programlisting>
<simpara>We defined the <literal>Queue</literal> protocol and as you may have noticed the implementation
of <literal>UnboundedQueue</literal> doesn&#8217;t know about transducers at all. It has a <literal>put!</literal>
operation as its step function and we&#8217;re going to implement the transducible
process on top of that interface:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn unbounded-queue
  ([]
   (unbounded-queue nil))
  ([xform]
   (let [put! (completing put!)
         xput! (if xform (xform put!) put!)
         q (UnboundedQueue. #js [] false)]
     (reify
       Queue
       (put! [_ item]
         (when-not (.-closed q)
           (let [val (xput! q item)]
             (if (reduced? val)
               (do
                 (xput! @val)  ;; call completion step
                 (shutdown! q) ;; respect reduced
                 @val)
               val))))
       (take! [_]
         (take! q))
       (shutdown! [_]
         (shutdown! q))))))</programlisting>
<simpara>As you can see, the <literal>unbounded-queue</literal> constructor uses an <literal>UnboundedQueue</literal>
instance internally, proxying the <literal>take!</literal> and <literal>shutdown!</literal> calls and implementing
the transducible process logic in the <literal>put!</literal> function. Let&#8217;s deconstruct it to
understand what&#8217;s going on.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [put! (completing put!)
      xput! (if xform (xform put!) put!)
      q (UnboundedQueue. #js [] false)]
  ;; ...
)</programlisting>
<simpara>First of all, we use <literal>completing</literal> for adding the arity 0 and arity 1 to the
<literal>Queue</literal> protocol&#8217;s <literal>put!</literal> function.  This will make it play nicely with
transducers in case we give this reducing function to <literal>xform</literal> to derive another.
After that, if a transducer (<literal>xform</literal>) was provided, we derive a reducing
function applying the transducer to <literal>put!</literal>.  If we&#8217;re not handed a transducer we
will just use <literal>put!</literal>. <literal>q</literal> is the internal instance of <literal>UnboundedQueue</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reify
  Queue
  (put! [_ item]
    (when-not (.-closed q)
      (let [val (xput! q item)]
        (if (reduced? val)
          (do
            (xput! @val)  ;; call completion step
            (shutdown! q) ;; respect reduced
            @val)
          val))))
  ;; ...
)</programlisting>
<simpara>The exposed <literal>put!</literal> operation will only be performed if the queue hasn&#8217;t been
shut down. Notice that the <literal>put!</literal> implementation of <literal>UnboundedQueue</literal> uses an
assert to verify that we can still put values to it and we don&#8217;t want to break
that invariant. If the queue isn&#8217;t closed we can put values into it, we use the
possibly transformed <literal>xput!</literal> for doing so.</simpara>
<simpara>If the put operation gives back a reduced value it&#8217;s telling us that we should
terminate the transducible process.  In this case that means shutting down the
queue to not accept more values. If we didn&#8217;t get a reduced value we can happily
continue accepting puts.</simpara>
<simpara>Let&#8217;s see how our queue behaves without transducers:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def q (unbounded-queue))
;; =&gt; #&lt;[object Object]&gt;

(put! q 1)
;; =&gt; 1
(put! q 2)
;; =&gt; 2

(take! q)
;; =&gt; 1
(take! q)
;; =&gt; 2
(take! q)
;; =&gt; nil</programlisting>
<simpara>Pretty much what we expected, let&#8217;s now try with a stateless transducer:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def incq (unbounded-queue (map inc)))
;; =&gt; #&lt;[object Object]&gt;

(put! incq 1)
;; =&gt; 2
(put! incq 2)
;; =&gt; 3

(take! incq)
;; =&gt; 2
(take! incq)
;; =&gt; 3
(take! incq)
;; =&gt; nil</programlisting>
<simpara>To check that we&#8217;ve implemented the transducible process, let&#8217;s use a stateful
transducer. We&#8217;ll use a transducer that will accept values while they aren&#8217;t
equal to 4 and will partition inputs in chunks of 2 elements:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def xq (unbounded-queue (comp
                           (take-while #(not= % 4))
                           (partition-all 2))))

(put! xq 1)
(put! xq 2)
;; =&gt; [1 2]
(put! xq 3)
(put! xq 4) ;; shouldn't accept more values from here on
(put! xq 5)
;; =&gt; nil

(take! xq)
;; =&gt; [1 2]
(take! xq) ;; seems like `partition-all` flushed correctly!
;; =&gt; [3]
(take! xq)
;; =&gt; nil</programlisting>
<simpara>The example of the queue was heavily inspired by how <literal>core.async</literal> channels use
transducers in their internal step. We&#8217;ll discuss channels and their usage with
transducers in a later section.</simpara>
<simpara>Transducible processes must respect <literal>reduced</literal> as a way for signaling early
termination. For example, building a collection stops when encountering a
<literal>reduced</literal> and <literal>core.async</literal> channels with transducers are closed.  The <literal>reduced</literal>
value must be unwrapped with <literal>deref</literal> and passed to the completion step, which
must be called exactly once.</simpara>
<simpara>Transducible processes shouldn&#8217;t expose the reducing function they generate when
calling the transducer with their own step function since it may be stateful and
unsafe to use from elsewhere.</simpara>
</section>
</section>
<section id="transients">
<title>Transients</title>
<simpara>Although ClojureScript&#8217;s immutable and persistent data structures are reasonably
performant there are situations in which we are transforming large data
structures using multiple steps to only share the final result. For example, the
core <literal>into</literal> function takes a collection and eagerly populates it with the
contents of a sequence:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(into [] (range 100))
;; =&gt; [0 1 2 ... 98 99]</programlisting>
<simpara>In the above example we are generating a vector of 100 elements <literal>conj</literal>-ing one at a
time. Every intermediate vector that is not the final result won&#8217;t be seen by anybody
except the <literal>into</literal> function and the array copying required for persistence is an
unnecesary overhead.</simpara>
<simpara>For these situations ClojureScript provides a special version of some of its
persistent data structures, which are called transients. Maps, vectors and sets have
a transient counterpart.  Transients are always derived from a persistent data
structure using the <literal>transient</literal> function, which creates a transient version in
constant time:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def tv (transient [1 2 3]))
;; =&gt; #&lt;[object Object]&gt;</programlisting>
<simpara>Transients support the read API of their persistent counterparts:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def tv (transient [1 2 3]))

(nth tv 0)
;; =&gt; 1

(get tv 2)
;; =&gt; 3

(def tm (transient {:language "ClojureScript"}))

(:language tm)
;; =&gt; "ClojureScript"

(def ts (transient #{:a :b :c}))

(contains? ts :a)
;; =&gt; true

(:a ts)
;; =&gt; :a</programlisting>
<simpara>Since transients don&#8217;t have persistent and immutable semantics for updates they
can&#8217;t be transformed using the already familiar <literal>conj</literal> or <literal>assoc</literal>
functions. Instead, the transforming functions that work on transients end with
a bang. Let&#8217;s look at an example using <literal>conj!</literal> on a transient:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def tv (transient [1 2 3]))

(conj! tv 4)
;; =&gt; #&lt;[object Object]&gt;

(nth tv 3)
;; =&gt; 4</programlisting>
<simpara>As you can see, the transient version of the vector is neither immutable nor
persistent. Instead, the vector is mutated in place. Although we could transform
<literal>tv</literal> repeatedly using <literal>conj!</literal> on it we shouldn&#8217;t abandon the idioms used with
the persistent data structures: when transforming a transient, use the returned
version of it for further modifications like in the following example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(-&gt; [1 2 3]
  transient
  (conj! 4)
  (conj! 5))
;; =&gt; #&lt;[object Object]&gt;</programlisting>
<simpara>We can convert a transient back to a persistent and immutable data structure by
calling <literal>persistent!</literal> on it. This operation, like deriving a transient from a
persistent data structure, is done in constant time.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(-&gt; [1 2 3]
  transient
  (conj! 4)
  (conj! 5)
  persistent!)
;; =&gt; [1 2 3 4 5]</programlisting>
<simpara>A peculiarity of transforming transients into persistent structures is that the
transient version is invalidated after being converted to a persistent data
structure and we can&#8217;t do further transformations to it. This happens because
the derived persistent data structure uses the transient&#8217;s internal nodes and
mutating them would break the immutability and persistent guarantees:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def tm (transient {}))
;; =&gt; #&lt;[object Object]&gt;

(assoc! tm :foo :bar)
;; =&gt; #&lt;[object Object]&gt;

(persistent! tm)
;; =&gt; {:foo :bar}

(assoc! tm :baz :frob)
;; Error: assoc! after persistent!</programlisting>
<simpara>Going back to our initial example with <literal>into</literal>, here&#8217;s a very simplified
implementation of it that uses a transient for performance, returning a
persistent data structure and thus exposing a purely functional interface
although it uses mutation internally:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-into
  [to from]
  (persistent! (reduce conj! (transient to) from)))

(my-into [] (range 100))
;; =&gt; [0 1 2 ... 98 99]</programlisting>
</section>
<section id="metadata-section">
<title>Metadata</title>
<simpara>ClojureScript symbols, vars and persistent collections support attaching
metadata to them. Metadata is a map with information about the entity it&#8217;s
attached to. The ClojureScript compiler uses metadata for several purposes such
as type hints, and the metadata system can be used by tooling, library and
application developers too.</simpara>
<simpara>There may not be many cases in day-to-day ClojureScript programming where you
need metadata, but it is a nice language feature to have and know about; it may
come in handy at some point. It makes things like runtime code introspection and
documentation generation very easy. You&#8217;ll see why throughout this section.</simpara>
<section id="vars-3">
<title>Vars</title>
<simpara>Let&#8217;s define a var and see what metadata is attached to it by default. Note that
this code is executed in a REPL, and thus the metadata of a var defined in a
source file may vary. We&#8217;ll use the <literal>meta</literal> function to retrieve the metadata of
the given value:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def answer-to-everything 42)
;; =&gt; 42

#'answer-to-everything
;; =&gt; #'cljs.user/answer-to-everyhing

(meta #'answer-to-everything)
;; =&gt; {:ns cljs.user,
;;     :name answer-to-everything,
;;     :file "NO_SOURCE_FILE",
;;     :source "answer-to-everything",
;;     :column 6,
;;     :end-column 26,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc nil,
;;     :test nil}</programlisting>
<simpara>Few things to note here. First of all, <literal>#'answer-to-everything</literal> gives us a
reference to the <literal>Var</literal> that holds the value of the <literal>answer-to-everything</literal>
symbol. We see that it includes information about the namespace (<literal>:ns</literal>) in which
it was defined, its name, file (although, since it was defined at a REPL doesn&#8217;t
have a source file), source, position in the file where it was defined, argument
list (which only makes sense for functions), documentation string and test
function.</simpara>
<simpara>Let&#8217;s take a look at a function var&#8217;s metadata:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn add
  "A function that adds two numbers."
  [x y]
  (+ x y))

(meta #'add)
;; =&gt; {:ns cljs.user,
;;     :name add,
;;     :file "NO_SOURCE_FILE",
;;     :source "add",
;;     :column 7,
;;     :end-column 10,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (quote ([x y])),
;;     :doc "A function that adds two numbers.",
;;     :test nil}</programlisting>
<simpara>We see that the argument lists are stored in the <literal>:arglists</literal> field of the var&#8217;s
metadata and its documentation in the <literal>:doc</literal> field. We&#8217;ll now define a test
function to learn about what <literal>:test</literal> is used for:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.test :as t])

(t/deftest i-pass
  (t/is true))

(meta #'i-pass)
;; =&gt; {:ns cljs.user,
;;     :name i-pass,
;;     :file "NO_SOURCE_FILE",
;;     :source "i-pass",
;;     :column 12,
;;     :end-column 18,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc "A function that adds two numbers.",
;;     :test #&lt;function (){ ... }&gt;}</programlisting>
<simpara>The <literal>:test</literal> attribute (truncated for brevity) in the <literal>i-pass</literal> var&#8217;s metadata is
a test function. This is used by the <literal>cljs.test</literal> library for discovering and
running tests in the namespaces you tell it to.</simpara>
</section>
<section id="values">
<title>Values</title>
<simpara>We learned that vars can have metadata and what kind of metadata is added to
them for consumption by the compiler and the <literal>cljs.test</literal> testing
library. Persistent collections can have metadata too, although they don&#8217;t have
any by default. We can use the <literal>with-meta</literal> function to derive an object with the
same value and type with the given metadata attached. Let&#8217;s see how:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def map-without-metadata {:language "ClojureScript"})
;; =&gt; {:language "ClojureScript"}

(meta map-without-metadata)
;; =&gt; nil

(def map-with-metadata (with-meta map-without-metadata
                                  {:answer-to-everything 42}))
;; =&gt; {:language "ClojureScript"}

(meta map-with-metadata)
;; =&gt; {:answer-to-everything 42}

(= map-with-metadata
   map-without-metadata)
;; =&gt; true

(identical? map-with-metadata
            map-without-metadata)
;; =&gt; false</programlisting>
<simpara>It shouldn&#8217;t come as a surprise that metadata doesn&#8217;t affect equality between
two data structures since equality in ClojureScript is based on value. Another
interesting thing is that <literal>with-meta</literal> creates another object of the same type
and value as the given one and attaches the given metadata to it.</simpara>
<simpara>Another open question is what happens with metadata when deriving new values
from a persistent data structure.  Let&#8217;s find out:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def derived-map (assoc map-with-metadata :language "Clojure"))
;; =&gt; {:language "Clojure"}

(meta derived-map)
;; =&gt; {:answer-to-everything 42}</programlisting>
<simpara>As you can see in the example above, metadata is preserved in derived versions
of persistent data structures. There are some subtleties, though. As long as the
functions that derive new data structures return collections with the same type,
metadata will be preserved; this is not true if the types change due to the
transformation. To ilustrate this point, let&#8217;s see what happens when we derive a
seq or a subvector from a vector:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def v (with-meta [0 1 2 3] {:foo :bar}))
;; =&gt; [0 1 2 3]

(def sv (subvec v 0 2))
;; =&gt; [0 1]

(meta sv)
;; =&gt; nil

(meta (seq v))
;; =&gt; nil</programlisting>
</section>
<section id="syntax-for-metadata">
<title>Syntax for metadata</title>
<simpara>The ClojureScript reader has syntactic support for metadata annotations, which
can be written in different ways. We can prepend var definitions or collections
with a caret (<literal>^</literal>) followed by a map for annotating it with the given metadata
map:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ^{:doc "The answer to Life, Universe and Everything."} answer-to-everything 42)
;; =&gt; 42

(meta #'answer-to-everything)
;; =&gt; {:ns cljs.user,
;;     :name answer-to-everything,
;;     :file "NO_SOURCE_FILE",
;;     :source "answer-to-everything",
;;     :column 6,
;;     :end-column 26,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc "The answer to Life, Universe and Everything.",
;;     :test nil}

(def map-with-metadata ^{:answer-to-everything 42} {:language "ClojureScript"})
;; =&gt; {:language "ClojureScript"}

(meta map-with-metadata)
;; =&gt; {:answer-to-everything 42}</programlisting>
<simpara>Notice how the metadata given in the <literal>answer-to-everything</literal> var definition is
merged with the var metadata.</simpara>
<simpara>A very common use of metadata is to set certain keys to a <literal>true</literal> value. For example
we may want to add to a var&#8217;s metadata that the variable is dynamic or a
constant. For such cases, we have a shorthand notation that uses a caret followed by
a keyword. Here are some examples:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ^:dynamic *foo* 42)
;; =&gt; 42

(:dynamic (meta #'*foo*))
;; =&gt; true

(def ^:foo ^:bar answer 42)
;; =&gt; 42

(select-keys (meta #'answer) [:foo :bar])
;; =&gt; {:foo true, :bar true}</programlisting>
<simpara>There is another shorthand notation for attaching metadata. If we use a caret
followed by a symbol it will be added to the metadata map under the <literal>:tag</literal>
key. Using tags such as <literal>^boolean</literal> gives the ClojureScript compiler hints about
the type of expressions or function return types.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn ^boolean will-it-blend? [_] true)
;; =&gt; #&lt;function ... &gt;

(:tag (meta #'will-it-blend?))
;; =&gt; boolean

(not ^boolean (js/isNaN js/NaN))
;; =&gt; false</programlisting>
</section>
<section id="functions-for-working-with-metadata">
<title>Functions for working with metadata</title>
<simpara>We&#8217;ve learned about <literal>meta</literal> and <literal>with-meta</literal> so far but ClojureScript offers a few
functions for transforming metadata. There is <literal>vary-meta</literal> which is similar to
<literal>with-meta</literal> in that it derives a new object with the same type and value as the
original but it doesn&#8217;t take the metadata to attach directly. Instead, it takes
a function to apply to the metadata of the given object to transform it for
deriving new metadata. This is how it works:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def map-with-metadata ^{:foo 40} {:language "ClojureScript"})
;; =&gt; {:language "ClojureScript"}

(meta map-with-metadata)
;; =&gt; {:foo 40}

(def derived-map (vary-meta map-with-metadata update :foo + 2))
;; =&gt; {:language "ClojureScript"}

(meta derived-map)
;; =&gt; {:foo 42}</programlisting>
<simpara>If instead we want to change the metadata of an existing var or value we can use
<literal>alter-meta!</literal> for changing it by applying a function or <literal>reset-meta!</literal> for
replacing it with another map:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def map-with-metadata ^{:foo 40} {:language "ClojureScript"})
;; =&gt; {:language "ClojureScript"}

(meta map-with-metadata)
;; =&gt; {:foo 40}

(alter-meta! map-with-metadata update :foo + 2)
;; =&gt; {:foo 42}

(meta map-with-metadata)
;; =&gt; {:foo 42}

(reset-meta! map-with-metadata {:foo 40})
;; =&gt; {:foo 40}

(meta map-with-metadata)
;; =&gt; {:foo 40}</programlisting>
</section>
</section>
<section id="core-protocols-section">
<title>Core protocols</title>
<simpara>One of the greatest qualities of the core ClojureScript functions is that they are
implemented around protocols. This makes them open to work on any type that we
extend with such protocols, be it defined by us or a third party.</simpara>
<section id="functions">
<title>Functions</title>
<simpara>As we&#8217;ve learned in previous chapters not only functions can be invoked. Vectors are
functions of their indexes, maps are functions of their keys and sets are functions
of their values.</simpara>
<simpara>We can extend types to be callable as functions implementing the <literal>IFn</literal> protocol. A
collection that doesn&#8217;t support calling it as a function is the queue, let&#8217;s
implement <literal>IFn</literal> for the <literal>PersistentQueue</literal> type so we&#8217;re able to call queues as
functions of their indexes:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type PersistentQueue
  IFn
  (-invoke
    ([this idx]
      (nth this idx))))

(def q #queue[:a :b :c])
;; =&gt; #queue [:a :b :c]

(q 0)
;; =&gt; :a

(q 1)
;; =&gt; :b

(q 2)
;; =&gt; :c</programlisting>
</section>
<section id="printing">
<title>Printing</title>
<simpara>For learning about some of the core protocols we&#8217;ll define a <literal>Pair</literal> type, which will
hold a pair of values.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype Pair [fst snd])</programlisting>
<simpara>If we want to customize how types are printed we can implement the
<literal>IPrintWithWriter</literal> protocol. It defines a function called <literal>-pr-writer</literal> that receives
the value to print, a writer object and options; this function uses the writer
object&#8217;s <literal>-write</literal> function to write the desired <literal>Pair</literal> string representation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#&lt;Pair " (.-fst p) "," (.-snd p) "&gt;"))))</programlisting>
</section>
<section id="sequences">
<title>Sequences</title>
<simpara>In a <link linkend="the-sequence-abstraction">previous section</link> we learned about sequences, one
of ClojureScript&#8217;s main abstractions. Remember the <literal>first</literal> and <literal>rest</literal> functions for
working with sequences? They are defined in the <literal>ISeq</literal> protocol, so we can extend
types for responding to such functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  ISeq
  (-first [p]
    (.-fst p))

  (-rest [p]
    (list (.-snd p))))

(def p (Pair. 1 2))
;; =&gt; #&lt;Pair 1,2&gt;

(first p)
;; =&gt; 1

(rest p)
;; =&gt; (2)</programlisting>
<simpara>Another handy function for working with sequences is <literal>next</literal>. Although <literal>next</literal> works
as long as the given argument is a sequence, we can implement it explicitly with the
<literal>INext</literal> protocol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def p (Pair. 1 2))

(next p)
;; =&gt; (2)

(extend-type Pair
  INext
  (-next [p]
    (println "Our next")
    (list (.-snd p))))

(next p)
;; Our next
;; =&gt; (2)</programlisting>
<simpara>Finally, we can make our own types seqable implementing the <literal>ISeqable</literal>
protocol. This means we can pass them to <literal>seq</literal> for getting a sequence back.</simpara>
<simpara>ISeqable</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def p (Pair. 1 2))

(extend-type Pair
  ISeqable
  (-seq [p]
    (list (.-fst p) (.-snd p))))

(seq p)
;; =&gt; (1 2)</programlisting>
<simpara>Now our <literal>Pair</literal> type works with the plethora of ClojureScript functions for working
with sequences:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def p (Pair. 1 2))
;; =&gt; #&lt;Pair 1,2&gt;

(map inc p)
;; =&gt; (2 3)

(filter odd? p)
;; =&gt; (1)

(reduce + p)
;; =&gt; 3</programlisting>
</section>
<section id="collections-2">
<title>Collections</title>
<simpara>Collection functions are also defined in terms of protocols. For this section
examples we will make the native JavaScript string act like a collection.</simpara>
<simpara>The most important function for working with collection is <literal>conj</literal>, defined in the
<literal>ICollection</literal> protocol.  Strings are the only type which makes sense to <literal>conj</literal> to a
string, so the <literal>conj</literal> operation for strings will be simply a concatenation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type string
  ICollection
  (-conj [this o]
    (str this o)))

(conj "foo" "bar")
;; =&gt; "foobar"

(conj "foo" "bar" "baz")
;; =&gt; "foobarbaz"</programlisting>
<simpara>Another handy function for working with collections is <literal>empty</literal>, which is part of the
<literal>IEmptyableCollection</literal> protocol. Let&#8217;s implement it for the string type:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type string
  IEmptyableCollection
  (-empty [_]
    ""))

(empty "foo")
;; =&gt; ""</programlisting>
<simpara>We used the <literal>string</literal> special symbol for extending the native JavaScript string. If
you want to learn more about it check the <link linkend="extending-javascript-types">section
about extending JavaScript types</link>.</simpara>
<section id="collection-traits">
<title>Collection traits</title>
<simpara>There are some qualities that not all collections have, such as being countable in
constant time or being reversible. These traits are splitted into different
protocols since not all of them make sense for every collection. For illustrating
these protocols we&#8217;ll use the <literal>Pair</literal> type we defined earlier.</simpara>
<simpara>For collections that can be counted in constant time using the <literal>count</literal> function we
can implement the <literal>ICounted</literal> protocol. It should be easy to implement it for the
<literal>Pair</literal> type:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  ICounted
  (-count [_]
    2))

(def p (Pair. 1 2))

(count p)
;; =&gt; 2</programlisting>
<simpara>Some collection types such as vectors and lists can be indexed by a number using the
<literal>nth</literal> function. If our types are indexed we can implement the <literal>IIndexed</literal> protocol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IIndexed
  (-nth
    ([p idx]
      (case idx
        0 (.-fst p)
        1 (.-snd p)
        (throw (js/Error. "Index out of bounds"))))
    ([p idx default]
      (case idx
        0 (.-fst p)
        1 (.-snd p)
        default))))

(nth p 0)
;; =&gt; 1

(nth p 1)
;; =&gt; 2

(nth p 2)
;; Error: Index out of bounds

(nth p 2 :default)
;; =&gt; :default</programlisting>
</section>
</section>
<section id="associative">
<title>Associative</title>
<simpara>There are many data structures that are associative: they map keys to values. We&#8217;ve
encountered a few of them already and we know many functions for working with them
like <literal>get</literal>, <literal>assoc</literal> or <literal>dissoc</literal>. Let&#8217;s explore the protocols that these functions
build upon.</simpara>
<simpara>First of all, we need a way to look up keys on an associative data structure. The
<literal>ILookup</literal> protocol defines a function for doing so, let&#8217;s add the ability to look up
keys in our <literal>Pair</literal> type since it is an associative data structure that maps the indices
0 and 1 to values.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  ILookup
  (-lookup
    ([p k]
      (-lookup p k nil))
    ([p k default]
      (case k
        0 (.-fst p)
        1 (.-snd p)
        default))))

(get p 0)
;; =&gt; 1

(get p 1)
;; =&gt; 2

(get p :foo)
;; =&gt; nil

(get p 2 :default)
;; =&gt; :default</programlisting>
<simpara>For using <literal>assoc</literal> on a data structure it must implement the <literal>IAssociative</literal>
protocol. For our <literal>Pair</literal> type only 0 and 1 will be allowed as keys for associating
values. <literal>IAssociative</literal> also has a function for asking whether a key is present or
not.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IAssociative
  (-contains-key? [_ k]
    (contains? #{0 1} k))

  (-assoc [p k v]
    (case k
      0 (Pair. v (.-snd p))
      1 (Pair. (.-fst p) v)
      (throw (js/Error. "Can only assoc to 0 and 1 keys")))))

(def p (Pair. 1 2))
;; =&gt; #&lt;Pair 1,2&gt;

(assoc p 0 2)
;; =&gt; #&lt;Pair 2,2&gt;

(assoc p 1 1)
;; =&gt; #&lt;Pair 1,1&gt;

(assoc p 0 0 1 1)
;; =&gt; #&lt;Pair 0,1&gt;

(assoc p 2 3)
;; Error: Can only assoc to 0 and 1 keys</programlisting>
<simpara>The complementary function for <literal>assoc</literal> is <literal>dissoc</literal> and it&#8217;s part of the <literal>IMap</literal>
protocol. It doesn&#8217;t make much sense for our <literal>Pair</literal> type but we&#8217;ll implement it
nonetheless. Dissociating 0 or 1 will mean putting a <literal>nil</literal> in such position and
invalid keys will be ignored.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IMap
  (-dissoc [p k]
    (case k
      0 (Pair. nil (.-snd p))
      1 (Pair. (.-fst p) nil)
      p)))

(def p (Pair. 1 2))
;; =&gt; #&lt;Pair 1,2&gt;

(dissoc p 0)
;; =&gt; #&lt;Pair ,2&gt;

(dissoc p 1)
;; =&gt; #&lt;Pair 1,&gt;

(dissoc p 2)
;; =&gt; #&lt;Pair 1,2&gt;

(dissoc p 0 1)
;; =&gt; #&lt;Pair ,&gt;</programlisting>
<simpara>Associative data structures are made of key and value pairs we can call entries. The
<literal>key</literal> and <literal>val</literal> functions allow us to query the key and value of such entries and
they are built upon the <literal>IMapEntry</literal> protocol. Let&#8217;s see a few examples of <literal>key</literal> and
<literal>val</literal> and how map entries can be used to build up maps:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(key [:foo :bar])
;; =&gt; :foo

(val [:foo :bar])
;; =&gt; :bar

(into {} [[:foo :bar] [:baz :xyz]])
;; =&gt; {:foo :bar, :baz :xyz}</programlisting>
<simpara>Pairs can be map entries too, we treat their first element as the key and the second
as the value:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IMapEntry
  (-key [p]
    (.-fst p))

  (-val [p]
    (.-snd p)))

(def p (Pair. 1 2))
;; =&gt; #&lt;Pair 1,2&gt;

(key p)
;; =&gt; 1

(val p)
;; =&gt; 2

(into {} [p])
;; =&gt; {1 2}</programlisting>
</section>
<section id="comparison">
<title>Comparison</title>
<simpara>For checking whether two or more values are equivalent with <literal>=</literal> we must implement
the <literal>IEquiv</literal> protocol. Let&#8217;s do it for our <literal>Pair</literal> type:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def p  (Pair. 1 2))
(def p' (Pair. 1 2))
(def p'' (Pair. 1 2))

(= p p')
;; =&gt; false

(= p p' p'')
;; =&gt; false

(extend-type Pair
  IEquiv
  (-equiv [p other]
    (and (instance? Pair other)
         (= (.-fst p) (.-fst other))
         (= (.-snd p) (.-snd other)))))

(= p p')
;; =&gt; true

(= p p' p'')
;; =&gt; true</programlisting>
<simpara>We can also make types comparable. The function <literal>compare</literal> takes two values and
returns a negative number if the first is less than the second, 0 if both are equal
and 1 if the first is greater than the second. For making our types comparable we
must implement the <literal>IComparable</literal> protocol.</simpara>
<simpara>For pairs, comparison will mean checking if the two first values are equal. If they
are, the result will be the comparison of the second values. If not, we will return
the result of the first comparison:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type Pair
  IComparable
  (-compare [p other]
    (let [fc (compare (.-fst p) (.-fst other))]
      (if (zero? fc)
        (compare (.-snd p) (.-snd other))
        fc))))

(compare (Pair. 0 1) (Pair. 0 1))
;; =&gt; 0

(compare (Pair. 0 1) (Pair. 0 2))
;; =&gt; -1

(compare (Pair. 1 1) (Pair. 0 2))
;; =&gt; 1

(sort [(Pair. 1 1) (Pair. 0 2) (Pair. 0 1)])
;; =&gt; (#&lt;Pair 0,1&gt; #&lt;Pair 0,2&gt; #&lt;Pair 1,1&gt;)</programlisting>
</section>
<section id="metadata">
<title>Metadata</title>
<simpara>The <literal>meta</literal> and <literal>with-meta</literal> functions are also based upon two protocols: <literal>IMeta</literal> and
<literal>IWithMeta</literal> respectively.  We can make our own types capable of carrying metadata
adding an extra field for holding the metadata and implementing both protocols.</simpara>
<simpara>Let&#8217;s implement a version of <literal>Pair</literal> that can have metadata:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype Pair [fst snd meta]
  IMeta
  (-meta [p] meta)

  IWithMeta
  (-with-meta [p new-meta]
    (Pair. fst snd new-meta)))


(def p (Pair. 1 2 {:foo :bar}))
;; =&gt; #&lt;Pair 1,2&gt;

(meta p)
;; =&gt; {:foo :bar}

(def p' (with-meta p {:bar :baz}))
;; =&gt; #&lt;Pair 1,2&gt;

(meta p')
;; =&gt; {:bar :baz}</programlisting>
</section>
<section id="interoperability-with-javascript">
<title>Interoperability with JavaScript</title>
<simpara>Since ClojureScript is hosted in a JavaScript VM we often need to convert
ClojureScript data structures to JavaScript ones and viceversa. We also may want to
make native JS types participate in an abstraction represented by a protocol.</simpara>
<section id="extending-javascript-types">
<title>Extending JavaScript types</title>
<simpara>When extending JavaScript objects instead of using JS globals like <literal>js/String</literal>,
<literal>js/Date</literal> and such, special symbols are used. This is done for avoiding mutating
global JS objects.</simpara>
<simpara>The symbols for extending JS types are: <literal>object</literal>, <literal>array</literal>, <literal>number</literal>, <literal>string</literal>,
<literal>function</literal>, <literal>boolean</literal> and <literal>nil</literal> is used for the null object. The dispatch of the
protocol to native objects uses Google Closure&#8217;s
<ulink url="https://google.github.io/closure-library/api/namespace_goog.html#typeOf">goog.typeOf</ulink>
function. There&#8217;s a special <literal>default</literal> symbol that can be used for making a default
implementation of a protocol for every type.</simpara>
<simpara>For illustrating the extension of JS types we are going to define a <literal>MaybeMutable</literal>
protocol that&#8217;ll have a <literal>mutable?</literal> predicate as its only function. Since in
JavaScript mutability is the default we&#8217;ll extend the default JS type returning true
from <literal>mutable?</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol MaybeMutable
  (mutable? [this] "Returns true if the value is mutable."))

(extend-type default
  MaybeMutable
  (mutable? [_] true))

;; object
(mutable? #js {})
;; =&gt; true

;; array
(mutable? #js [])
;; =&gt; true

;; string
(mutable? "")
;; =&gt; true

;; function
(mutable? (fn [x] x))
;; =&gt; true</programlisting>
<simpara>Since fortunately not all JS object&#8217;s values are mutable we can refine the
implementation of <literal>MaybeMutable</literal> for returning <literal>false</literal> for strings and functions.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-protocol MaybeMutable
  string
  (mutable? [_] false)

  function
  (mutable? [_] false))


;; object
(mutable? #js {})
;; =&gt; true

;; array
(mutable? #js [])
;; =&gt; true

;; string
(mutable? "")
;; =&gt; false

;; function
(mutable? (fn [x] x))
;; =&gt; false</programlisting>
<simpara>There is no special symbol for JavaScript dates so we have to extend <literal>js/Date</literal>
directly. The same applies to the rest of the types found in the global <literal>js</literal>
namespace.</simpara>
</section>
<section id="converting-data">
<title>Converting data</title>
<simpara>For converting values from ClojureScript types to JavaScript ones and viceversa we
use the <literal>clj&#8594;js</literal> and <literal>js&#8594;clj</literal> functions, which are based in the <literal>IEncodeJS</literal> and
<literal>IEncodeClojure</literal> protocols respectively.</simpara>
<simpara>For the examples we&#8217;ll use the Set type introduced in ES6. Note that is not
available in every JS runtime.</simpara>
<section id="from-clojurescript-to-js">
<title>From ClojureScript to JS</title>
<simpara>First of all we&#8217;ll extend ClojureScript&#8217;s set type for being able to convert it to
JS. By default sets are converted to JavaScript arrays:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(clj-&gt;js #{1 2 3})
;; =&gt; #js [1 3 2]</programlisting>
<simpara>Let&#8217;s fix it, <literal>clj&#8594;js</literal> is supposed to convert values recursively so we&#8217;ll make sure
to convert all the set contents to JS and creating the set with the converted
values:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type PersistentHashSet
  IEncodeJS
  (-clj-&gt;js [s]
    (js/Set. (into-array (map clj-&gt;js s)))))

(def s (clj-&gt;js #{1 2 3}))
(es6-iterator-seq (.values s))
;; =&gt; (1 3 2)

(instance? js/Set s)
;; =&gt; true

(.has s 1)
;; =&gt; true
(.has s 2)
;; =&gt; true
(.has s 3)
;; =&gt; true
(.has s 4)
;; =&gt; false</programlisting>
<simpara>The <literal>es6-iterator-seq</literal> is an experimental function in ClojureScript core for
obtaining a seq from an ES6 iterable.</simpara>
</section>
<section id="from-js-to-clojurescript">
<title>From JS to ClojureScript</title>
<simpara>Now it&#8217;s time to extend the JS set to convert to ClojureScript. As with <literal>clj&#8594;js</literal>,
<literal>js&#8594;clj</literal> recursively converts the value of the data structure:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/Set
  IEncodeClojure
  (-js-&gt;clj [s options]
    (into #{} (map js-&gt;clj (es6-iterator-seq (.values s))))))

(= #{1 2 3}
   (js-&gt;clj (clj-&gt;js #{1 2 3})))
;; =&gt; true

(= #{[1 2 3] [4 5] [6]}
   (js-&gt;clj (clj-&gt;js #{[1 2 3] [4 5] [6]})))
;; =&gt; true</programlisting>
<simpara>Note that there is no one-to-one mapping between ClojureScript and JavaScript
values. For example, ClojureScript keywords are converted to JavaScript strings when
passed to <literal>clj&#8594;js</literal>.</simpara>
</section>
</section>
</section>
<section id="reductions">
<title>Reductions</title>
<simpara>The <literal>reduce</literal> function is based on the <literal>IReduce</literal> protocol, which enables us to make
our own or third-party types reducible. Apart from using them with <literal>reduce</literal> they
will automatically work with <literal>transduce</literal> too, which will allow us to make a
reduction with a transducer.</simpara>
<simpara>The JS array is already reducible in ClojureScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce + #js [1 2 3])
;; =&gt; 6

(transduce (map inc) conj [] [1 2 3])
;; =&gt; [2 3 4]</programlisting>
<simpara>However, the new ES6 Set type isn&#8217;t so let&#8217;s implement the <literal>IReduce</literal> protocol. We&#8217;ll
get an iterator using the Set&#8217;s <literal>values</literal> method and convert it to a seq with the
<literal>es6-iterator-seq</literal> function; after that we&#8217;ll delegate to the original <literal>reduce</literal>
function to reduce the obtained sequence.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/Set
  IReduce
  (-reduce
   ([s f]
     (let [it (.values s)]
       (reduce f (es6-iterator-seq it))))
   ([s f init]
     (let [it (.values s)]
       (reduce f init (es6-iterator-seq it))))))

(reduce + (js/Set. #js [1 2 3]))
;; =&gt; 6

(transduce (map inc) conj [] (js/Set. #js [1 2 3]))
;; =&gt; [2 3 4]</programlisting>
<simpara>Associative data structures can be reduced with the <literal>reduce-kv</literal> function, which is
based in the <literal>IKVReduce</literal> protocol. The main difference between <literal>reduce</literal> and
<literal>reduce-kv</literal> is that the latter uses a three-argument function as a reducer,
receiving the accumulator, key and value for each item.</simpara>
<simpara>Let&#8217;s look at an example, we will reduce a map to a vector of pairs. Note that,
since vectors associate indexes to values, they can also be reduced with
<literal>reduce-kv</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce-kv (fn [acc k v]
             (conj acc [k v]))
           []
           {:foo :bar
            :baz :xyz})
;; =&gt; [[:foo :bar] [:baz :xyz]]</programlisting>
<simpara>We&#8217;ll extend the new ES6 map type to support <literal>reduce-kv</literal>, we&#8217;ll do this by getting a
sequence of key-value pairs and calling the reducing function with the accumulator,
key and value as positional arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/Map
  IKVReduce
  (-kv-reduce [m f init]
   (let [it (.entries m)]
     (reduce (fn [acc [k v]]
               (f acc k v))
             init
             (es6-iterator-seq it)))))

(def m (js/Map.))
(.set m "foo" "bar")
(.set m "baz" "xyz")

(reduce-kv (fn [acc k v]
             (conj acc [k v]))
           []
           m)
;; =&gt; [["foo" "bar"] ["baz" "xyz"]]</programlisting>
<simpara>In both examples we ended up delegating to the <literal>reduce</literal> function, which is aware of
reduced values and terminates when encountering one. Take into account that if you
don&#8217;t implement these protocols in terms of <literal>reduce</literal> you will have to check for
reduced values for early termination.</simpara>
</section>
<section id="delayed-computation">
<title>Delayed computation</title>
<simpara>There are some types that have the notion of asynchronous computation, the value
they represent may not be realized yet. We can ask whether a value is realized using
the <literal>realized?</literal> predicate.</simpara>
<simpara>Let&#8217;s ilustrate it with the <literal>Delay</literal> type, which takes a computation and executes it
when the result is needed.  When we dereference a delay the computation is run and
the delay is realized:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn computation []
  (println "running!")
  42)

(def d (delay (computation)))

(realized? d)
;; =&gt; false

(deref d)
;; running!
;; =&gt; 42

(realized? d)
;; =&gt; true

@d
;; =&gt; 42</programlisting>
<simpara>Both <literal>realized?</literal> and <literal>deref</literal> sit atop two protocols: <literal>IPending</literal> and <literal>IDeref</literal>.</simpara>
</section>
<section id="state">
<title>State</title>
<simpara>The ClojureScript state constructs such as the Atom and the Volatile have different
characteristics and semantics, and the operations on them like <literal>add-watch</literal>, <literal>reset!</literal>
or <literal>swap!</literal> are backed by protocols.</simpara>
<section id="atom">
<title>Atom</title>
<simpara>For ilustrating such protocols we will implement our own simplified version of an
<literal>Atom</literal>. It won&#8217;t support validators nor metadata, but we will be able to:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>deref</literal> the atom for getting its current value</simpara>
</listitem>
<listitem>
<simpara><literal>reset!</literal> the value contained in the atom</simpara>
</listitem>
<listitem>
<simpara><literal>swap!</literal> the atom with a function for transforming its state</simpara>
</listitem>
</itemizedlist>
<simpara><literal>deref</literal> is based on the <literal>IDeref</literal> protocol. <literal>reset!</literal> is based on the <literal>IReset</literal>
protocol and <literal>swap!</literal> on <literal>ISwap</literal>. We&#8217;ll start by defining a data type and a
constructor for our atom implementation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype MyAtom [^:mutable state ^:mutable watches]
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#&lt;MyAtom " (pr-str state) "&gt;"))))

(defn my-atom
  ([]
    (my-atom nil))
  ([init]
    (MyAtom. init {})))

(my-atom)
;; =&gt; #&lt;MyAtom nil&gt;

(my-atom 42)
;; =&gt; #&lt;MyAtom 42&gt;</programlisting>
<simpara>Note that we&#8217;ve marked both the current state of the atom (<literal>state</literal>) and the map of
watchers (<literal>watches</literal>) with the <literal>{:mutable true}</literal> metadata. We&#8217;ll be modifying them
and we&#8217;re making this explicit with the annotations.</simpara>
<simpara>Our <literal>MyAtom</literal> type is not very useful yet, we&#8217;ll start by implementing the <literal>IDeref</literal>
protocol so we can dereference its current value:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type MyAtom
  IDeref
  (-deref [a]
    (.-state a)))

(def a (my-atom 42))

@a
;; =&gt; 42</programlisting>
<simpara>Now that we can dereference it we&#8217;ll implement the <literal>IWatchable</literal> protocol, which will
let us add and remove watches to our custom atom. We&#8217;ll store the watches in the
<literal>watches</literal> map of <literal>MyAtom</literal>, associating keys to callbacks.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type MyAtom
  IWatchable
  (-add-watch [a key f]
    (let [ws (.-watches a)]
      (set! (.-watches a) (assoc ws key f))))

  (-remove-watch [a key]
    (let [ws (.-watches a)]
      (set! (.-watches a) (dissoc ws key))))

  (-notify-watches [a oldval newval]
    (doseq [[key f] (.-watches a)]
      (f key a oldval newval))))</programlisting>
<simpara>We can now add watches to our atom but is not very useful since we still can&#8217;t
change it. For incorporating change we have to implement the <literal>IReset</literal> protocol and
make sure we notify the watches every time we reset the atom&#8217;s value.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type MyAtom
  IReset
  (-reset! [a newval]
    (let [oldval (.-state a)]
      (set! (.-state a) newval)
      (-notify-watches a oldval newval)
      newval)))</programlisting>
<simpara>Now let&#8217;s check that we got it right. We&#8217;ll add a watch, change the atom&#8217;s value
making sure the watch gets called and then remove it:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def a (my-atom 41))
;; =&gt; #&lt;MyAtom 41&gt;

(add-watch a :log (fn [key a oldval newval]
                    (println {:key key
                              :old oldval
                              :new newval})))
;; =&gt; #&lt;MyAtom 41&gt;

(reset! a 42)
;; {:key :log, :old 41, :new 42}
;; =&gt; 42

(remove-watch a :log)
;; =&gt; #&lt;MyAtom 42&gt;

(reset! a 43)
;; =&gt; 43</programlisting>
<simpara>Our atom is still missing the swapping functionality so we&#8217;ll add that now, let&#8217;s
implement the <literal>ISwap</literal> protocol. There are four arities for the <literal>-swap!</literal> method of
the protocol since the function passed to <literal>swap!</literal> may take one, two, three or more
arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type MyAtom
  ISwap
  (-swap!
   ([a f]
    (let [oldval (.-state a)
          newval (f oldval)]
      (reset! a newval)))

   ([a f x]
     (let [oldval (.-state a)
           newval (f oldval x)]
       (reset! a newval)))

   ([a f x y]
     (let [oldval (.-state a)
           newval (f oldval x y)]
       (reset! a newval)))

   ([a f x y more]
     (let [oldval (.-state a)
           newval (apply f oldval x y more)]
       (reset! a newval)))))</programlisting>
<simpara>We now have a custom implementation of the atom abstraction, let&#8217;s test it in the
REPL and see if it behaves like we expect:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def a (my-atom 0))
;; =&gt; #&lt;MyAtom 0&gt;

(add-watch a :log (fn [key a oldval newval]
                    (println {:key key
                              :old oldval
                              :new newval})))
;; =&gt; #&lt;MyAtom 0&gt;

(swap! a inc)
;; {:key :log, :old 0, :new 1}
;; =&gt; 1

(swap! a + 2)
;; {:key :log, :old 1, :new 3}
;; =&gt; 3

(swap! a - 2)
;; {:key :log, :old 3, :new 1}
;; =&gt; 1

(swap! a + 2 3)
;; {:key :log, :old 1, :new 6}
;; =&gt; 6


(swap! a + 4 5 6)
;; {:key :log, :old 6, :new 21}
;; =&gt; 21

(swap! a * 2)
;; {:key :log, :old 21, :new 42}
;; =&gt; 42

(remove-watch a :log)
;; =&gt; #&lt;MyAtom 42&gt;</programlisting>
<simpara>We did it! We implemented a version of ClojureScript Atom without support for
metadata nor validators, extending it to support such features is left as an
exercise for the reader. Note that you&#8217;ll need to modify the <literal>MyAtom</literal> type for being
able to store metadata and a validator.</simpara>
</section>
<section id="volatile">
<title>Volatile</title>
<simpara>Volatiles are simpler than atoms in that they don&#8217;t support watching for
changes. All changes override the previous value much like the mutable variables
present in almost every programming language. Volatiles are based on the <literal>IVolatile</literal>
protocol that only defines a method for <literal>vreset!</literal>, since <literal>vswap!</literal> is implemented as
a macro.</simpara>
<simpara>Let&#8217;s start by creating our own volatile type and constructor:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype MyVolatile [^:mutable state]
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#&lt;MyVolatile " (pr-str state) "&gt;"))))

(defn my-volatile
  ([]
    (my-volatile nil))
  ([v]
    (MyVolatile. v)))

(my-volatile)
;; =&gt; #&lt;MyVolatile nil&gt;

(my-volatile 42)
;; =&gt; #&lt;MyVolatile 42&gt;</programlisting>
<simpara>Our <literal>MyVolatile</literal> still needs to support dereferencing and reseting it, let&#8217;s
implement <literal>IDeref</literal> and <literal>IVolatile</literal>, which will enable use to use <literal>deref</literal>, <literal>vreset!</literal>
and <literal>vswap!</literal> in our custom volatile:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type MyVolatile
  IDeref
  (-deref [v]
    (.-state v))

  IVolatile
  (-vreset! [v newval]
    (set! (.-state v) newval)
    newval))

(def v (my-volatile 0))
;; =&gt; #&lt;MyVolatile 42&gt;

(vreset! v 1)
;; =&gt; 1

@v
;; =&gt; 1

(vswap! v + 2 3)
;; =&gt; 6

@v
;; =&gt; 6</programlisting>
</section>
</section>
<section id="mutation">
<title>Mutation</title>
<simpara>In the <link linkend="transients">section about transients</link> we learned about the mutable
counterparts of the immutable and persistent data structures that ClojureScript
provides. These data structures are mutable, and the operations on them end with a
bang (<literal>!</literal>) to make that explicit. As you may have guessed every operation on
transients is based on protocols.</simpara>
<section id="from-persistent-to-transient-and-viceversa">
<title>From persistent to transient and viceversa</title>
<simpara>We&#8217;ve learned that we can transform a persistent data structure with the <literal>transient</literal>
function, which is based on the <literal>IEditableCollection</literal> protocol; for transforming a
transient data structure to a persistent one we use <literal>persistent!</literal>, based on
<literal>ITransientCollection</literal>.</simpara>
<simpara>Implementing immutable and persistent data structures and their transient
counterparts is out of the scope of this book but we recommend taking a look at
ClojureScript&#8217;s data structure implementation if you are curious.</simpara>
</section>
<section id="transient-vectors-and-sets">
<title>Transient vectors and sets</title>
<simpara>We&#8217;ve learned about most of the protocols for transient data structures but we&#8217;re
missing two: <literal>ITransientVector</literal> for using <literal>assoc!</literal> on transient vectors and
<literal>ITransientSet</literal> for using <literal>disj!</literal> on transient sets.</simpara>
<simpara>For illustrating the <literal>ITransientVector</literal> protocol we&#8217;ll extend the JavaScript array
type for making it an associative transient data structure:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type array
  ITransientAssociative
  (-assoc! [arr key val]
    (if (number? key)
      (-assoc-n! arr key val)
      (throw (js/Error. "Array's key for assoc! must be a number."))))

  ITransientVector
  (-assoc-n! [arr n val]
    (.splice arr n 1 val)
    arr))

(def a #js [1 2 3])
;; =&gt; #js [1 2 3]

(assoc! a 0 42)
;; =&gt; #js [42 2 3]

(assoc! a 1 43)
;; =&gt; #js [42 43 3]

(assoc! a 2 44)
;; =&gt; #js [42 43 44]</programlisting>
<simpara>For illustrating the <literal>ITransientSet</literal> protocol we&#8217;ll extend the ES6 Set type for
making it a transient set, supporting the <literal>conj!</literal>, <literal>disj!</literal> and <literal>persistent!</literal>
operations. Note that we&#8217;ve extended the Set type previously for being able to
convert it to ClojureScript and we&#8217;ll take advantage of that fact.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/Set
  ITransientCollection
  (-conj! [s v]
    (.add s v)
    s)

  (-persistent! [s]
   (js-&gt;clj s))

  ITransientSet
  (-disjoin! [s v]
    (.delete s v)
    s))

(def s (js/Set.))

(conj! s 1)
(conj! s 1)
(conj! s 2)
(conj! s 2)

(persistent! s)
;; =&gt; #{1 2}

(disj! s 1)

(persistent! s)
;; =&gt; #{2}</programlisting>
</section>
</section>
</section>
<section id="csp-with-core-async">
<title>CSP (with core.async)</title>
<simpara>CSP stands for Communicating Sequential Processes, which is a formalism for
describing concurrent systems pioneered by C. A. R. Hoare in 1978. It is a
concurrency model based on message passing and synchronization through channels.  An
in-depth look at the theoretical model behind CSP is beyond the scope of this book;
instead we&#8217;ll focus on presenting the concurrency primitives that <literal>core.async</literal>
offers.</simpara>
<simpara><literal>core.async</literal> is not part of ClojureScript core but it&#8217;s implemented as a library.
Even though it is not part of the core language it&#8217;s widely used. Many libraries build
on top of the <literal>core.async</literal> primitives, so we think it is worth covering in the book.
It&#8217;s also a good example of the syntactic abstractions that can be achieved by
transforming code with ClojureScript macros, so we&#8217;ll jump right in. You&#8217;ll need to
have <literal>core.async</literal> installed to run the examples presented in this section.</simpara>
<section id="channels">
<title>Channels</title>
<simpara>Channels are like conveyor belts, we can put and take a single value at a time from
them. They can have multiple readers and writers, and they are the fundamental
message-passing mechanism of <literal>core.async</literal>. In order to see how it works, we&#8217;ll
create a channel to perform some operations on it.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(enable-console-print!)

(def ch (chan))

(take! ch #(println "Got a value:" %))
;; =&gt; nil

;; there is a now a pending take operation, let's put something on the channel

(put! ch 42)
;; Got a value: 42
;; =&gt; 42</programlisting>
<simpara>In the above example we created a channel <literal>ch</literal> using the <literal>chan</literal> constructor.  After
that we performed a take operation on the channel, providing a callback that will be
invoked when the take operation succeeds. After using <literal>put!</literal> to put a value on the
channel the take operation completed and the <literal>"Got a value: 42"</literal> string was
printed. Note that <literal>put!</literal> returned the value that was just put to the channel.</simpara>
<simpara>The <literal>put!</literal> function accepts a callback like <literal>take!</literal> does but we didn&#8217;t provide any
in the last example. For puts the callback will be called whenever the value we
provided has been taken. Puts and takes can happen in any order, let&#8217;s do a few puts
followed by takes to illustrate the point:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan))

(put! ch 42 #(println "Just put 42"))
;; =&gt; true
(put! ch 43 #(println "Just put 43"))
;; =&gt; true

(take! ch #(println "Got" %))
;; Got 42
;; Just put 42
;; =&gt; nil

(take! ch #(println "Got" %))
;; Got 43
;; Just put 43
;; =&gt; nil</programlisting>
<simpara>You may be asking yourself why the <literal>put!</literal> operations return <literal>true</literal>. It signals that
the put operation could be performed, even though the value hasn&#8217;t yet been taken.
Channels can be closed, which will cause the put operations to not succeed:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! close!]])

(def ch (chan))

(close! ch)
;; =&gt; nil

(put! ch 42)
;; =&gt; false</programlisting>
<simpara>The above example was the simplest possible situation but what happens with pending
operations when a channel is closed? Let&#8217;s do a few takes and close the channel and
see what happens:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take! close!]])

(def ch (chan))

(take! ch #(println "Got value:" %))
;; =&gt; nil
(take! ch #(println "Got value:" %))
;; =&gt; nil

(close! ch)
;; Got value: nil
;; Got value: nil
;; =&gt; nil</programlisting>
<simpara>We see that if the channel is closed all the <literal>take!</literal> operations receive a <literal>nil</literal>
value. <literal>nil</literal> in channels is a sentinel value that signals to takers that the channel
has been closed. Because of that, putting a <literal>nil</literal> value on a channel is not allowed:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put!]])

(def ch (chan))

(put! ch nil)
;; Error: Assert failed: Can't put nil in on a channel</programlisting>
<section id="buffers">
<title>Buffers</title>
<simpara>We&#8217;ve seen that pending take and put operations are enqueued in a channel but, what
happens when there are many pending take or put operations? Let&#8217;s find out by
hammering a channel with many puts and takes:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan))

(dotimes [n 1025]
  (put! ch n))
;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.

(def ch (chan))

(dotimes [n 1025]
  (take! ch #(println "Got" %)))
;; Error: Assert failed: No more than 1024 pending takes are allowed on a single channel.</programlisting>
<simpara>As the example above shows there&#8217;s a limit of pending puts or takes on a channel,
it&#8217;s currently 1024 but that is an implementation detail that may change. Note that
there can&#8217;t be both pending puts and pending takes on a channel since puts will
immediately succeed if there are pending takes and viceversa.</simpara>
<simpara>Channels support buffering of put operations. If we create a channel with a buffer
the put operations will succeed immediately if there&#8217;s room in the buffer and be
enqueued otherwise. Let&#8217;s illustrate the point creating a channel with a buffer of
one element. The <literal>chan</literal> constructors accepts a number as its first argument which
will cause it to have a buffer with the given size:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1))

(put! ch 42 #(println "Put succeeded!"))
;; Put succeeded!
;; =&gt; true

(dotimes [n 1024]
  (put! ch n))
;; =&gt; nil

(put! ch 42)
;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.</programlisting>
<simpara>What happened in the example above? We created a channel with a buffer of size 1 and
performed a put operation on it that succeeded immediately because the value was
buffered. After that we did another 1024 puts to fill the pending put queue and,
when trying to put one value more the channel complained about not being able to
enqueue more puts.</simpara>
<simpara>Now that we know about how channels work and what are buffers used for let&#8217;s explore
the different buffers that <literal>core.async</literal> implements. Different buffers have different
policies and it&#8217;s interesting to know all of them to know when to use what. Channels
are unbuffered by default.</simpara>
<section id="fixed">
<title>Fixed</title>
<simpara>The fixed size buffer is the one that is created when we give the <literal>chan</literal> constructor
a number and it will have the size specified by the given number. It is the simplest
possible buffer: when full, puts will be enqueued.</simpara>
<simpara>The <literal>chan</literal> constructor accepts either a number or a buffer as its first argument.
The two channels created in the following example both use a fixed buffer of size
32:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan buffer]])

(def a-ch (chan 32))

(def another-ch (chan (buffer 32)))</programlisting>
</section>
<section id="dropping">
<title>Dropping</title>
<simpara>The fixed buffer allows put operations to be enqueued. However, as we saw before,
puts are still queued when the fixed buffer is full. If we wan&#8217;t to discard the put
operations that happen when the buffer is full we can use a dropping buffer.</simpara>
<simpara>Dropping buffers have a fixed size and, when they are full puts will complete but
their value will be discarded. Let&#8217;s illustrate the point with an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan dropping-buffer put! take!]])

(def ch (chan (dropping-buffer 2)))

(put! ch 40)
;; =&gt; true
(put! ch 41)
;; =&gt; true
(put! ch 42)
;; =&gt; true

(take! ch #(println "Got" %))
;; Got 40
;; =&gt; nil
(take! ch #(println "Got" %))
;; Got 41
;; =&gt; nil
(take! ch #(println "Got" %))
;; =&gt; nil</programlisting>
<simpara>We performed three put operations and the three of them succeded but, since the
dropping buffer of the channel has size 2, only the first two values were delivered
to the takers. As you can observe the third take is enqueued since there is no value
available, the third put&#8217;s value (42) was discarded.</simpara>
</section>
<section id="sliding">
<title>Sliding</title>
<simpara>The sliding buffer has the opposite policy than the dropping buffer. When full puts
will complete and the oldest value will be discarded in favor of the new one.  The
sliding buffer is useful when we are interested in processing the last puts only and
we can afford discarding old values.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan sliding-buffer put! take!]])

(def ch (chan (sliding-buffer 2)))

(put! ch 40)
;; =&gt; true
(put! ch 41)
;; =&gt; true
(put! ch 42)
;; =&gt; true

(take! ch #(println "Got" %))
;; Got 41
;; =&gt; nil
(take! ch #(println "Got" %))
;; Got 42
;; =&gt; nil
(take! ch #(println "Got" %))
;; =&gt; nil</programlisting>
<simpara>We performed three put operations and the three of them succeded but, since the
sliding buffer of the channel has size 2, only the last two values were delivered to
the takers. As you can observe the third take is enqueued since there is no value
available since the first put&#8217;s value was discarded.</simpara>
</section>
</section>
<section id="transducers-2">
<title>Transducers</title>
<simpara>As mentioned in the section about transducers, putting values in a channel can be
thought as a transducible process. This means that we can create channels and hand
them a transducer, giving us the ability to transform the input values before being
put in the channel.</simpara>
<simpara>If we want to use a transducer with a channel we must supply a buffer since the
reducing function that will be modified by the transducer will be the buffer&#8217;s add
function. A buffer&#8217;s add function is a reducing function since it takes a buffer and
an input and returns a buffer with such input incorporated.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1 (map inc)))

(put! ch 41)
;; =&gt; true

(take! ch #(println "Got" %))
;; Got 42
;; =&gt; nil</programlisting>
<simpara>You may be wondering what happens to a channel when the reducing function returns a
reduced value. It turns out that the notion of termination for channels is being
closed, so channels will be closed when a reduced value is encountered:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1 (take 2)))

(take! ch #(println "Got" %))
;; =&gt; nil
(take! ch #(println "Got" %))
;; =&gt; nil
(take! ch #(println "Got" %))
;; =&gt; nil

(put! ch 41)
;; =&gt; true
(put! ch 42)
;; Got 41
;; =&gt; true
(put! ch 43)
;; Got 42
;; Got nil
;; =&gt; false</programlisting>
<simpara>We used the <literal>take</literal> stateful transducer to allow maximum 2 puts into the channel.  We
then performed three take operations on the channel and we expect only two to
receive a value. As you can see in the above example the third take got the sentinel
<literal>nil</literal> value which indicates that the channel was closed. Also, the third put
operation returned <literal>false</literal> indicating that it didn&#8217;t take place.</simpara>
</section>
<section id="handling-exceptions">
<title>Handling exceptions</title>
<simpara>If adding a value to a buffer throws an exception <literal>core.async</literal> the operation will
fail and the exception will be logged to the console. However, channel constructors
accept a third argument: a function for handling exceptions.</simpara>
<simpara>When creating a channel with an exception handler it will be called with the
exception whenever an exception occurs. If the handler returns <literal>nil</literal> the operation
will fail silently and if it returns another value the add operation will be retried
with such value.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! take!]])

(enable-console-print!)

(defn exception-xform
  [rfn]
  (fn [acc input]
    (throw (js/Error. "I fail!"))))

(defn handle-exception
  [ex]
  (println "Exception message:" (.-message ex))
  42)

(def ch (chan 1 exception-xform handle-exception))

(put! ch 0)
;; Exception message: I fail!
;; =&gt; true

(take! ch #(println "Got:" %))
;; Got: 42
;; =&gt; nil</programlisting>
</section>
<section id="offer-and-poll">
<title>Offer and Poll</title>
<simpara>We&#8217;ve learned about the two basic operations on channels so far: <literal>put!</literal> and <literal>take!</literal>.
They either take or put a value and are enqueued if they can&#8217;t be performed
immediately. Both functions are asynchronous because of their nature: they can
succeed but be completed at a later time.</simpara>
<simpara><literal>core.async</literal> has two synchronous operations for putting or taking values: <literal>offer!</literal>
and <literal>poll!</literal>. Let&#8217;s see how they work through examples.</simpara>
<simpara><literal>offer!</literal> puts a value in a channel if it&#8217;s possible to do so immediately. It returns
<literal>true</literal> if the channel received the value and <literal>false</literal> otherwise. Note that, unlike
with <literal>put!</literal>, <literal>offer!</literal> cannot distinguish between closed and open channels.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan offer!]])

(def ch (chan 1))

(offer! ch 42)
;; =&gt; true

(offer! ch 43)
;; =&gt; false</programlisting>
<simpara><literal>poll!</literal> takes a value from a channel if it&#8217;s possible to do so immediately. Returns
the value if succesful and <literal>nil</literal> otherwise. Unlike <literal>take!</literal>, <literal>poll!</literal> cannot
distinguish closed and open channels.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan offer! poll!]])

(def ch (chan 1))

(poll! ch)
;; =&gt; nil

(offer! ch 42)
;; =&gt; true

(poll! ch)
;; =&gt; 42</programlisting>
</section>
</section>
<section id="processes">
<title>Processes</title>
<simpara>We learned all about channels but there is still a missing piece in the puzzle:
processes.  Processes are pieces of logic that run independently and use channels
for communication and coordination. Puts and takes inside a process will stop the
process until the operation completes. Stopping a process doesn&#8217;t block the only
thread we have in the environments where ClojureScript runs. Instead, it will be
resumed at a later time when the operation is waiting for being performed.</simpara>
<simpara>Processes are launched using the <literal>go</literal> macro and puts and takes use the <literal>&lt;!</literal> and <literal>&gt;!</literal>
placeholders. The <literal>go</literal> macro rewrites your code to use callbacks but inside <literal>go</literal>
everything looks like synchronous code, which makes understanding it
straightforward:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan &lt;! &gt;!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def ch (chan))

(go
  (println [:a] "Gonna take from channel")
  (println [:a] "Got" (&lt;! ch)))

(go
  (println [:b] "Gonna put on channel")
  (&gt;! ch 42)
  (println [:b] "Just put 42"))

;; [:a] Gonna take from channel
;; [:b] Gonna put on channel
;; [:b] Just put 42
;; [:a] Got 42</programlisting>
<simpara>In the above example we are launching a process with <literal>go</literal> that takes a value from
<literal>ch</literal> and prints it to the console. Since the value isn&#8217;t immediately available it
will park until it can resume. After that we launch another process that puts a
value on the channel.</simpara>
<simpara>Since there is a pending take the put operation succeeds and the value is delivered
to the first process, then both processes terminate.</simpara>
<simpara>Both <literal>go</literal> blocks run independently and, even though they are executed
asynchronously, they look like synchronous code. The above go blocks are fairly
simple but being able to write concurrent processes that coordinate via channels is
a very powerful tool for implementing complex asynchronous workflows. Channels also
offer a great decoupling of producers and consumers.</simpara>
<simpara>Processes can wait for an arbitrary amount of time too, there is a <literal>timeout</literal>
function that return a channel that will be closed after the given amount of
miliseconds. Combining a timeout channel with a take operation inside a go block
gives us the ability to sleep:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [&lt;! timeout]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(defn seconds
  []
  (.getSeconds (js/Date.)))

(println "Launching go block")

(go
  (println [:a] "Gonna take a nap" (seconds))
  (&lt;! (timeout 1000))
  (println [:a] "I slept one second, bye!" (seconds)))

(println "Block launched")

;; Launching go block
;; Block launched
;; [:a] Gonna take a nap 9
;; [:a] I slept one second, bye! 10</programlisting>
<simpara>As we can see in the messages printed, the process does nothing for one second when
it blocks in the take operation of the timeout channel. The program continues and
after one second the process resumes and terminates.</simpara>
<section id="choice">
<title>Choice</title>
<simpara>Apart from putting and taking one value at a time inside a go block we can also make
a non-deterministic choice on multiple channel operations using <literal>alts!</literal>.  <literal>alts!</literal> is
given a series of channel put or take operations (note that we can also try to put
and take in a channel at the same time) and only performs one as soon as is ready;
if multiple operations can be performed when calling <literal>alts!</literal> it will do a pseudo
random choice by default.</simpara>
<simpara>We can easily try an operation on a channel and cancel it after a certain amount of
time combining the <literal>timeout</literal> function and <literal>alts!</literal>. Let&#8217;s see how:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan &lt;! timeout alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def ch (chan))

(go
  (println [:a] "Gonna take a nap")
  (&lt;! (timeout 1000))
  (println [:a] "I slept one second, trying to put a value on channel")
  (&gt;! ch 42)
  (println [:a] "I'm done!"))

(go
  (println [:b] "Gonna try taking from channel")
  (let [cancel (timeout 300)
        [value ch] (alts! [ch cancel])]
    (if (= ch cancel)
      (println [:b] "Too slow, take from channel cancelled")
      (println [:b] "Got" value))))

;; [:a] Gonna take a nap
;; [:b] Gonna try taking from channel
;; [:b] Too slow, take from channel cancelled
;; [:a] I slept one second, trying to put a value on channel</programlisting>
<simpara>In the example above we launched a go block that, after waiting for a second, puts a
value in the <literal>ch</literal> channel. The other go block creates a <literal>cancel</literal> channel, which will
be closed after 300 miliseconds. After that, it tries to read from both <literal>ch</literal> and
<literal>cancel</literal> at the same time using <literal>alts!</literal>, which will succeed whenever it can take a
value from either of those channels. Since <literal>cancel</literal> is closed after 300 miliseconds,
<literal>alts!</literal> will succeed since takes from closed channel return the <literal>nil</literal> sentinel. Note
that <literal>alts!</literal> returns a two-element vector with the returned value of the operation
and the channel where it was performed.</simpara>
<simpara>This is why we are able to detect whether the read operation was performed in the
<literal>cancel</literal> channel or in <literal>ch</literal>. I suggest you copy this example and set the first
process timeout to 100 miliseconds to see how the read operation on <literal>ch</literal> succeeds.</simpara>
<simpara>We&#8217;ve learned how to choose between read operations so let&#8217;s look at how to express
a conditional write operation in <literal>alts!</literal>. Since we need to provide the channel and a
value to try to put on it, we&#8217;ll use a two element vector with the channel and the
value for representing write operations.</simpara>
<simpara>Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan &lt;! alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Take a value from `a-ch`")
  (println [:a] "Got" (&lt;! a-ch))
  (println [:a] "I'm done!"))

(go
  (println [:b] "Take a value from `another-ch`")
  (println [:a] "Got" (&lt;! another-ch))
  (println [:b] "I'm done!"))

(go
  (println [:c] "Gonna try putting in both channels simultaneously")
  (let [[value ch] (alts! [[a-ch 42]
                           [another-ch 99]])]
    (if (= ch a-ch)
      (println [:c] "Put a value in `a-ch`")
      (println [:c] "Put a value in `another-ch`"))))

;; [:a] Take a value from `a-ch`
;; [:b] Take a value from `another-ch`
;; [:c] Gonna try putting in both channels simultaneously
;; [:c] Put a value in `a-ch`
;; [:a] Got 42
;; [:a] I'm done!</programlisting>
<simpara>When running the above example only the put operation on the <literal>a-ch</literal> channel has
succeeded. Since both channels are ready to take a value when the <literal>alts!</literal> occurs you
may get different results when running this code.</simpara>
</section>
<section id="priority">
<title>Priority</title>
<simpara><literal>alts!</literal> default is to make a non-deterministic choice whenever several operations
are ready to be performed. We can instead give priority to the operations passing
the <literal>:priority</literal> option to <literal>alts!</literal>. Whenever <literal>:priority</literal> is <literal>true</literal>, if more than one
operation is ready they will be tried in order.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan &gt;! alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Put a value on `a-ch`")
  (&gt;! a-ch 42)
  (println [:a] "I'm done!"))

(go
  (println [:b] "Put a value on `another-ch`")
  (&gt;! another-ch 99)
  (println [:b] "I'm done!"))

(go
  (println [:c] "Gonna try taking from both channels with priority")
  (let [[value ch] (alts! [a-ch another-ch] :priority true)]
    (if (= ch a-ch)
      (println [:c] "Got" value "from `a-ch`")
      (println [:c] "Got" value "from `another-ch`"))))

;; [:a] Put a value on `a-ch`
;; [:a] I'm done!
;; [:b] Put a value on `another-ch`
;; [:b] I'm done!
;; [:c] Gonna try taking from both channels with priority
;; [:c] Got 42 from `a-ch`</programlisting>
<simpara>Since both <literal>a-ch</literal> and <literal>another-ch</literal> had a value to read when the <literal>alts!</literal> was executed
and we set the <literal>:priority</literal> option to true, <literal>a-ch</literal> has preference. You can try
deleting the <literal>:priority</literal> option and running the example multiple times to see that,
without priority, <literal>alts!</literal> makes a non-deterministic choice.</simpara>
</section>
<section id="defaults">
<title>Defaults</title>
<simpara>Another interesting bit of <literal>alts!</literal> is that it can return immediately if no operation
is ready and we provide a default value. We can conditionally do a choice on the
operations if and only if any of them is ready, returning a default value if it&#8217;s
not.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Gonna try taking from any of the channels without blocking")
  (let [[value ch] (alts! [a-ch another-ch] :default :not-ready)]
    (if (and (= value :not-ready)
             (= ch :default))
      (println [:a] "No operation is ready, aborting")
      (println [:a] "Got" value))))

;; [:a] Gonna try taking from any of the channels without blocking
;; [:a] No operation is ready, aborting</programlisting>
<simpara>As you can see in the above example, if no operation is ready the value returned by
<literal>alts!</literal> is the one we supplied after the <literal>:default</literal> key when calling it and the
channel is the <literal>:default</literal> keyword itself.</simpara>
</section>
</section>
<section id="combinators">
<title>Combinators</title>
<simpara>Now that we&#8217;re acquainted with channels and processes it&#8217;s time to explore some
interesting combinators for working with channels that are present in <literal>core.async</literal>.
This section includes a brief description of all of them together with a simple
example of their usage.</simpara>
<section id="pipe">
<title>pipe</title>
<simpara><literal>pipe</literal> takes an input and output channels and pipes all the values put on the input
channel to the output one. The output channel is closed whenever the source is
closed unless we provide a <literal>false</literal> third argument:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan pipe put! &lt;! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))

(pipe in out)

(go-loop [value (&lt;! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (&lt;! out)))))

(put! in 0)
;; =&gt; true
(put! in 1)
;; =&gt; true
(close! in)

;; [:a] Got 0
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] I'm done!</programlisting>
<simpara>In the above example we used the <literal>go-loop</literal> macro for reading values recursively
until the <literal>out</literal> channel is closed. Notice that when we close the <literal>in</literal> channel the
<literal>out</literal> channel is closed too, making the <literal>go-loop</literal> terminate.</simpara>
</section>
<section id="pipeline-async">
<title>pipeline-async</title>
<simpara><literal>pipeline-async</literal> takes a number for controlling parallelism, an output channel, an
asynchronous function and an input channel. The asynchronous function has two
arguments: the value put in the input channel and a channel where it should put the
result of its asynchronous operation, closing the result channel after finishing.
The number controls the number of concurrent go blocks that will be used for calling
the asynchronous function with the inputs.</simpara>
<simpara>The output channel will receive outputs in an order relative to the input channel,
regardless the time each asynchronous function call takes to complete. It has an
optional last parameter that controls whether the output channel will be closed when
the input channel is closed, which defaults to <literal>true</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan pipeline-async put! &lt;! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))
(def parallelism 3)

(defn wait-and-put [value ch]
  (let [wait (rand-int 1000)]
    (js/setTimeout (fn []
                     (println "Waiting" wait "miliseconds for value" value)
                     (put! ch wait)
                     (close! ch))
                   wait)))

(pipeline-async parallelism out wait-and-put in)

(go-loop [value (&lt;! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (&lt;! out)))))

(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; Waiting 164 miliseconds for value 3
;; Waiting 304 miliseconds for value 2
;; Waiting 908 miliseconds for value 1
;; [:a] Got 908
;; [:a] Waiting for a value
;; [:a] Got 304
;; [:a] Waiting for a value
;; [:a] Got 164
;; [:a] Waiting for a value
;; [:a] I'm done!</programlisting>
</section>
<section id="pipeline">
<title>pipeline</title>
<simpara><literal>pipeline</literal> is similar to <literal>pipeline-async</literal> but instead of taking and asynchronous
function it takes a transducer instead. The transducer will be applied independently
to each input.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan pipeline put! &lt;! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))
(def parallelism 3)

(pipeline parallelism out (map inc) in)

(go-loop [value (&lt;! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (&lt;! out)))))

(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] Got 3
;; [:a] Waiting for a value
;; [:a] Got 4
;; [:a] Waiting for a value
;; [:a] I'm done!</programlisting>
</section>
<section id="split">
<title>split</title>
<simpara><literal>split</literal> takes a predicate and a channel and returns a vector with two channels, the
first of which will receive the values for which the predicate is true, the second
will receive those for which the predicate is false. We can optionally pass a buffer
or number for the channels with the third (true channel) and fourth (false channel)
arguments.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan split put! &lt;! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def chans (split even? in))
(def even-ch (first chans))
(def odd-ch (second chans))

(go-loop [value (&lt;! even-ch)]
  (if (nil? value)
    (println [:evens] "I'm done!")
    (do
      (println [:evens] "Got" value)
      (println [:evens] "Waiting for a value")
      (recur (&lt;! even-ch)))))

(go-loop [value (&lt;! odd-ch)]
  (if (nil? value)
    (println [:odds] "I'm done!")
    (do
      (println [:odds] "Got" value)
      (println [:odds] "Waiting for a value")
      (recur (&lt;! odd-ch)))))

(put! in 0)
(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; [:evens] Got 0
;; [:evens] Waiting for a value
;; [:odds] Got 1
;; [:odds] Waiting for a value
;; [:odds] Got 3
;; [:odds] Waiting for a value
;; [:evens] Got 2
;; [:evens] Waiting for a value
;; [:evens] I'm done!
;; [:odds] I'm done!</programlisting>
</section>
<section id="reduce">
<title>reduce</title>
<simpara><literal>reduce</literal> takes a reducing function, initial value and an input channel. It returns a
channel with the result of reducing over all the values put on the input channel
before closing it using the given initial value as the seed.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :as async :refer [chan put! &lt;! close!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def in (chan))

(go
  (println "Result" (&lt;! (async/reduce + (+) in))))

(put! in 0)
(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; Result: 6</programlisting>
</section>
<section id="onto-chan">
<title>onto-chan</title>
<simpara><literal>onto-chan</literal> takes a channel and a collection and puts the contents of the collection
into the channel. It closes the channel after finishing although it accepts a third
argument for specifying if it should close it or not. Let&#8217;s rewrite the <literal>reduce</literal>
example using <literal>onto-chan</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :as async :refer [chan put! &lt;! close! onto-chan]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def in (chan))

(go
  (println "Result" (&lt;! (async/reduce + (+) in))))

(onto-chan in [0 1 2 3])

;; Result: 6</programlisting>
</section>
<section id="to-chan">
<title>to-chan</title>
<simpara><literal>to-chan</literal> takes a collection and returns a channel where it will put every value in
the collection, closing the channel afterwards.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! &lt;! close! to-chan]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def ch (to-chan (range 3)))

(go-loop [value (&lt;! ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (&lt;! ch)))))

;; [:a] Got 0
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] I'm done!</programlisting>
</section>
<section id="merge">
<title>merge</title>
<simpara><literal>merge</literal> takes a collection of input channels and returns a channel where it will put
every value that is put on the input channels. The returned channel will be closed
when all the input channels have been closed. The returned channel will be
unbuffered by default but a number or buffer can be provided as the last argument.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! &lt;! close! merge]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in1 (chan))
(def in2 (chan))
(def in3 (chan))

(def out (merge [in1 in2 in3]))

(go-loop [value (&lt;! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (&lt;! out)))))

(put! in1 1)
(close! in1)
(put! in2 2)
(close! in2)
(put! in3 3)
(close! in3)

;; [:a] Got 3
;; [:a] Waiting for a value
;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] I'm done!</programlisting>
</section>
</section>
<section id="higher-level-abstractions">
<title>Higher-level abstractions</title>
<simpara>We&#8217;ve learned the about the low-level primitives of <literal>core.async</literal> and the combinators
that it offers for working with channels. <literal>core.async</literal> also offers some useful,
higher-level abstractions on top of channels that can serve as building blocks for
more advanced functionality.</simpara>
<section id="mult">
<title>Mult</title>
<simpara>Whenever we have a channel whose values have to be broadcasted to many others, we
can use <literal>mult</literal> for creating a multiple of the supplied channel. Once we have a mult,
we can attach channels to it using <literal>tap</literal> and dettach them using <literal>untap</literal>. Mults also
support removing all tapped channels at once with <literal>untap-all</literal>.</simpara>
<simpara>Every value put in the source channel of a mult is broadcasted to all the tapped
channels, and all of them must accept it before the next item is broadcasted. For
preventing slow takers from blocking the mult&#8217;s values we must use buffering on the
tapped channels judiciously.</simpara>
<simpara>Closed tapped channels are removed automatically from the mult. When putting a value
in the source channels when there are still no taps such value will be dropped.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! &lt;! close! timeout mult tap]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Source channel and mult
(def in (chan))
(def m-in (mult in))

;; Sink channels
(def a-ch (chan))
(def another-ch (chan))

;; Taker for `a-ch`
(go-loop [value (&lt;! a-ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (recur (&lt;! a-ch)))))

;; Taker for `another-ch`, which sleeps for 3 seconds between takes
(go-loop [value (&lt;! another-ch)]
  (if (nil? value)
    (println [:b] "I'm done!")
    (do
      (println [:b] "Got" value)
      (println [:b] "Resting 3 seconds")
      (&lt;! (timeout 3000))
      (recur (&lt;! another-ch)))))

;; Tap the two channels to the mult
(tap m-in a-ch)
(tap m-in another-ch)

;; See how the values are delivered to `a-ch` and `another-ch`
(put! in 1)
(put! in 2)

;; [:a] Got 1
;; [:b] Got 1
;; [:b] Resting for 3 seconds
;; [:a] Got 2
;; [:b] Got 2
;; [:b] Resting for 3 seconds</programlisting>
</section>
<section id="pub-sub">
<title>Pub-sub</title>
<simpara>After learning about mults you could imagine how to implement a pub-sub abstraction
on top of <literal>mult</literal>, <literal>tap</literal> and <literal>untap</literal> but since it&#8217;s a widely used communication
mechanism <literal>core.async</literal> already implements this functionality.</simpara>
<simpara>Instead of creating a mult from a source channel, we create a publication with <literal>pub</literal>
giving it a channel and a function that will be used for extracting the topic of the
messages.</simpara>
<simpara>We can subscribe to a publication with <literal>sub</literal>, giving it the publication we want to
subscribe to, the topic we are interested in and a channel to put the messages that
have the given topic. Note that we can subscribe a channel to multiple topics.</simpara>
<simpara><literal>unsub</literal> can be given a publication, topic and channel for unsubscribing such channel
from the topic. <literal>unsub-all</literal> can be given a publication and a topic to unsubscribe
every channel from the given topic.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! &lt;! close! pub sub]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Source channel and publication
(def in (chan))
(def publication (pub in :action))

;; Sink channels
(def a-ch (chan))
(def another-ch (chan))

;; Channel with `:increment` action
(sub publication :increment a-ch)

(go-loop [value (&lt;! a-ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Increment:" (inc (:value value)))
      (recur (&lt;! a-ch)))))

;; Channel with `:double` action
(sub publication :double another-ch)

(go-loop [value (&lt;! another-ch)]
  (if (nil? value)
    (println [:b] "I'm done!")
    (do
      (println [:b] "Double:" (* 2 (:value value)))
      (recur (&lt;! another-ch)))))

;; See how values are delivered to `a-ch` and `another-ch` depending on their action
(put! in {:action :increment :value 98})
(put! in {:action :double :value 21})

;; [:a] Increment: 99
;; [:b] Double: 42</programlisting>
</section>
<section id="mixer">
<title>Mixer</title>
<simpara>As we learned in the section about <literal>core.async</literal> combinators, we can use the <literal>merge</literal>
function for combining multiple channels into one. When merging multiple channels,
every value put in the input channels will end up in the merged channel. However, we
may want more finer-grained control over which values put in the input channels end
up in the output channel, that&#8217;s where mixers come in handy.</simpara>
<simpara><literal>core.async</literal> gives us the mixer abstraction, which we can use to combine multiple
input channnels into an output channel. The interesting part of the mixer is that we
can mute, pause and listen exclusively to certain input channels.</simpara>
<simpara>We can create a mixer given an output channel with <literal>mix</literal>. Once we have a mixer we
can add input channels into the mix using <literal>admix</literal>, remove it using <literal>unmix</literal> or remove
every input channel with <literal>unmix-all</literal>.</simpara>
<simpara>For controlling the state of the input channel we use the <literal>toggle</literal> function giving
it the mixer and a map from channels to their states. Note that we can add channels
to the mix using <literal>toggle</literal>, since the map will be merged with the current state of
the mix. The state of a channel is a map which can have the keys <literal>:mute</literal>, <literal>:pause</literal>
and <literal>:solo</literal> mapped to a boolean.</simpara>
<simpara>Let&#8217;s see what muting, pausing and soloing channels means:</simpara>
<itemizedlist>
<listitem>
<simpara>A muted input channel means that, while still taking values from it, they won&#8217;t
be forwarded to the output channel. Thus, while a channel is muted, all the values
put in it will be discarded.</simpara>
</listitem>
<listitem>
<simpara>A paused input channel means that no values will be taken from it. This means
that values put in the channel won&#8217;t be forwarded to the output channel nor
discarded.</simpara>
</listitem>
<listitem>
<simpara>When soloing one or more channels the output channel will only receive the values
put in soloed channels. By default non-soloed channels are muted but we can use
<literal>solo-mode</literal> to decide between muting or pausing non-soloed channels.</simpara>
</listitem>
</itemizedlist>
<simpara>That was a lot of information so let&#8217;s see an example to improve our understanding.
First of all, we&#8217;ll set up a mixer with an <literal>out</literal> channel and add three input
channels to the mix. After that, we&#8217;ll be printing all the values received on the
<literal>out</literal> channel to illustrate the control over input channels:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require '[cljs.core.async :refer [chan put! &lt;! close! mix admix
                                   unmix toggle solo-mode]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Output channel and mixer
(def out (chan))
(def mixer (mix out))

;; Input channels
(def in-1 (chan))
(def in-2 (chan))
(def in-3 (chan))

(admix mixer in-1)
(admix mixer in-2)
(admix mixer in-3)

;; Let's listen to the `out` channel and print what we get from it
(go-loop [value (&lt;! out)]
  (if (nil? value)
    (println [:a] "I'm done")
    (do
      (println [:a] "Got" value)
      (recur (&lt;! out)))))</programlisting>
<simpara>By default, every value put in the input channels will be put in the <literal>out</literal> channel:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 2
;; [:a] Got 3</programlisting>
<simpara>Let&#8217;s pause the <literal>in-2</literal> channel, put a value in every input channel and resume <literal>in-2</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(toggle mixer {in-2 {:pause true}})
;; =&gt; true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 3

(toggle mixer {in-2 {:pause false}})

;; [:a] Got 2</programlisting>
<simpara>As you can see in the example above, the values put in the paused channels aren&#8217;t
discarded. For discarding values put in an input channel we have to mute it, let&#8217;s
see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(toggle mixer {in-2 {:mute true}})
;; =&gt; true

(do
  (put! in-1 1)
  (put! in-2 2)  ;; `out` will never get this value since it's discarded
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 3

(toggle mixer {in-2 {:mute false}})</programlisting>
<simpara>We put a value <literal>2</literal> in the <literal>in-2</literal> channel and, since the channel was muted at the
time, the value is discarded and never put into <literal>out</literal>. Let&#8217;s look at the third state
a channel can be inside a mixer: solo.</simpara>
<simpara>As we mentioned before, soloing channels of a mixer implies muting the rest of them
by default:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(toggle mixer {in-1 {:solo true}
               in-2 {:solo true}})
;; =&gt; true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3)) ;; `out` will never get this value since it's discarded

;; [:a] Got 1
;; [:a] Got 2

(toggle mixer {in-1 {:solo false}
               in-2 {:solo false}})</programlisting>
<simpara>However, we can set the mode the non-soloed channels will be in while there are
soloed channels. Let&#8217;s set the default non-solo mode to pause instead of the default
mute:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(solo-mode mixer :pause)
;; =&gt; true
(toggle mixer {in-1 {:solo true}
               in-2 {:solo true}})
;; =&gt; true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 2

(toggle mixer {in-1 {:solo false}
               in-2 {:solo false}})

;; [:a] Got 3</programlisting>
</section>
</section>
</section>
</chapter>
<chapter id="acknowledgments">
<title>Acknowledgments</title>
<simpara>Special thanks to:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">J David Eisenberg</emphasis>: For the huge amount of time spend in fixing all kind of errors and
writing entire sections of the book, as well as making very valuable suggestions.</simpara>
</listitem>
</itemizedlist>
<simpara>And here is an inevitably incomplete list of MUCH-APPRECIATED CONTRIBUTORS&#8201;&#8212;&#8201;people who have submitted corrections, new ideas and generally made the
<emphasis>ClojureScript Unraveled</emphasis> book much better:</simpara>
<itemizedlist>
<listitem>
<simpara>Anler Hernández Peral (@anler)</simpara>
</listitem>
<listitem>
<simpara>Diego Sevilla Ruiz (@dsevilla)</simpara>
</listitem>
<listitem>
<simpara>Eduardo Ferro Aldama (@eferro)</simpara>
</listitem>
<listitem>
<simpara>Tyler Anderson (@Tyler-Anderson)</simpara>
</listitem>
<listitem>
<simpara>Chris Ulrich (@chrisulrich)</simpara>
</listitem>
<listitem>
<simpara>Jean Hadrien Chabran (@jhchabran)</simpara>
</listitem>
<listitem>
<simpara>Tienson Qin (@tiensonqin)</simpara>
</listitem>
<listitem>
<simpara>FungusHumungus (@FungusHumungus),</simpara>
</listitem>
<listitem>
<simpara>Chris Charles (@ccharles)</simpara>
</listitem>
<listitem>
<simpara>Jearvon Dharrie (@iamjarvo)</simpara>
</listitem>
<listitem>
<simpara>Shaun LeBron (@shaunlebron)</simpara>
</listitem>
<listitem>
<simpara>Wodin (@wodin)</simpara>
</listitem>
<listitem>
<simpara>Crocket (@crocket)</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter id="further-reading">
<title>Further Reading</title>
<simpara>Here is a list of more resources about ClojureScript.</simpara>
<itemizedlist>
<listitem>
<simpara><ulink url="https://github.com/clojure/clojurescript/wiki">ClojureScript wiki</ulink>: a community-mantained wiki about ClojureScript.</simpara>
</listitem>
<listitem>
<simpara><ulink url="https://github.com/cljsinfo/cljs-api-docs/blob/catalog/INDEX.md">API Reference</ulink>: a community-maintained complete language api reference.</simpara>
</listitem>
<listitem>
<simpara><ulink url="http://cljs.info/cheatsheet/">ClojureScript Cheatsheet</ulink>: a comprehensive reference of the ClojureScript language.</simpara>
</listitem>
<listitem>
<simpara><ulink url="http://catcode.com/etudes-for-clojurescript/toc.html">Études for ClojureScript</ulink>: a collection of exercises for learning ClojureScript.</simpara>
</listitem>
<listitem>
<simpara><ulink url="http://clojurescriptmadeeasy.com/">ClojureScript made easy</ulink>: a collection of short articles about solving common problems in ClojureScript.</simpara>
</listitem>
<listitem>
<simpara><ulink url="http://google.github.io/closure-library/api/">The Google Closure Library API reference</ulink></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>